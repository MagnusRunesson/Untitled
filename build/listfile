F00:0001       _chunk_size		equ		128			; same as TD_SECTOR (size of sector on floppy)
F00:0002       
F00:0003       	include		"../src/platform/megadrive/macros.asm"
F01:0001       ;
F01:0002       ; Will set the border color to index 0 in the palette. Might get modified so the color index is a parameter.
F01:0003       ;
F01:0004       perf_start		MACRO
F01:0006       
F01:0007       
F01:0008       
F01:0009       ;
F01:0010       ; Will set the border color to index 1 in the palette. Might get modified so the color index is a parameter.
F01:0011       ;
F01:0012       perf_stop		MACRO
F01:0014       
F01:0015       
F01:0016       
F00:0004       
F00:0005       	include		"../src/platform/megadrive/bootup.asm"
F02:0001       	; Sega Genesis ROM header
F02:0002       	dc.l	$00FFE000	; Initial stack pointer value
               S01:00000000:  00 FF E0 00
F02:0003       	dc.l	$00000200	; Start of our program in ROM
               S01:00000004:  00 00 02 00
F02:0004       	dc.l	Interrupt	; Bus error
               S01:00000008:  00 00 02 7E
F02:0005       	dc.l	Interrupt	; Address error
               S01:0000000C:  00 00 02 7E
F02:0006       	dc.l	Interrupt	; Illegal instruction
               S01:00000010:  00 00 02 7E
F02:0007       	dc.l	Interrupt	; Division by zero
               S01:00000014:  00 00 02 7E
F02:0008       	dc.l	Interrupt	; CHK exception
               S01:00000018:  00 00 02 7E
F02:0009       	dc.l	Interrupt	; TRAPV exception
               S01:0000001C:  00 00 02 7E
F02:0010       	dc.l	Interrupt	; Privilege violation
               S01:00000020:  00 00 02 7E
F02:0011       	dc.l	Interrupt	; TRACE exception
               S01:00000024:  00 00 02 7E
F02:0012       	dc.l	Interrupt	; Line-A emulator
               S01:00000028:  00 00 02 7E
F02:0013       	dc.l	Interrupt	; Line-F emulator
               S01:0000002C:  00 00 02 7E
F02:0014       	dc.l	Interrupt	; Unused (reserved)
               S01:00000030:  00 00 02 7E
F02:0015       	dc.l	Interrupt	; Unused (reserved)
               S01:00000034:  00 00 02 7E
F02:0016       	dc.l	Interrupt	; Unused (reserved)
               S01:00000038:  00 00 02 7E
F02:0017       	dc.l	Interrupt	; Unused (reserved)
               S01:0000003C:  00 00 02 7E
F02:0018       	dc.l	Interrupt	; Unused (reserved)
               S01:00000040:  00 00 02 7E
F02:0019       	dc.l	Interrupt	; Unused (reserved)
               S01:00000044:  00 00 02 7E
F02:0020       	dc.l	Interrupt	; Unused (reserved)
               S01:00000048:  00 00 02 7E
F02:0021       	dc.l	Interrupt	; Unused (reserved)
               S01:0000004C:  00 00 02 7E
F02:0022       	dc.l	Interrupt	; Unused (reserved)
               S01:00000050:  00 00 02 7E
F02:0023       	dc.l	Interrupt	; Unused (reserved)
               S01:00000054:  00 00 02 7E
F02:0024       	dc.l	Interrupt	; Unused (reserved)
               S01:00000058:  00 00 02 7E
F02:0025       	dc.l	Interrupt	; Unused (reserved)
               S01:0000005C:  00 00 02 7E
F02:0026       	dc.l	Interrupt	; Spurious exception
               S01:00000060:  00 00 02 7E
F02:0027       	dc.l	Interrupt	; IRQ level 1
               S01:00000064:  00 00 02 7E
F02:0028       	dc.l	Interrupt	; IRQ level 2
               S01:00000068:  00 00 02 7E
F02:0029       	dc.l	Interrupt	; IRQ level 3
               S01:0000006C:  00 00 02 7E
F02:0030       	dc.l	HBlankInterrupt	; IRQ level 4 (horizontal retrace interrupt)
               S01:00000070:  00 00 02 80
F02:0031       	dc.l	Interrupt	; IRQ level 5
               S01:00000074:  00 00 02 7E
F02:0032       	dc.l	VBlankInterrupt	; IRQ level 6 (vertical retrace interrupt)
               S01:00000078:  00 00 02 88
F02:0033       	dc.l	Interrupt	; IRQ level 7
               S01:0000007C:  00 00 02 7E
F02:0034       	dc.l	Interrupt	; TRAP #00 exception
               S01:00000080:  00 00 02 7E
F02:0035       	dc.l	Interrupt	; TRAP #01 exception
               S01:00000084:  00 00 02 7E
F02:0036       	dc.l	Interrupt	; TRAP #02 exception
               S01:00000088:  00 00 02 7E
F02:0037       	dc.l	Interrupt	; TRAP #03 exception
               S01:0000008C:  00 00 02 7E
F02:0038       	dc.l	Interrupt	; TRAP #04 exception
               S01:00000090:  00 00 02 7E
F02:0039       	dc.l	Interrupt	; TRAP #05 exception
               S01:00000094:  00 00 02 7E
F02:0040       	dc.l	Interrupt	; TRAP #06 exception
               S01:00000098:  00 00 02 7E
F02:0041       	dc.l	Interrupt	; TRAP #07 exception
               S01:0000009C:  00 00 02 7E
F02:0042       	dc.l	Interrupt	; TRAP #08 exception
               S01:000000A0:  00 00 02 7E
F02:0043       	dc.l	Interrupt	; TRAP #09 exception
               S01:000000A4:  00 00 02 7E
F02:0044       	dc.l	Interrupt	; TRAP #10 exception
               S01:000000A8:  00 00 02 7E
F02:0045       	dc.l	Interrupt	; TRAP #11 exception
               S01:000000AC:  00 00 02 7E
F02:0046       	dc.l	Interrupt	; TRAP #12 exception
               S01:000000B0:  00 00 02 7E
F02:0047       	dc.l	Interrupt	; TRAP #13 exception
               S01:000000B4:  00 00 02 7E
F02:0048       	dc.l	Interrupt	; TRAP #14 exception
               S01:000000B8:  00 00 02 7E
F02:0049       	dc.l	Interrupt	; TRAP #15 exception
               S01:000000BC:  00 00 02 7E
F02:0050       	dc.l	Interrupt	; Unused (reserved)
               S01:000000C0:  00 00 02 7E
F02:0051       	dc.l	Interrupt	; Unused (reserved)
               S01:000000C4:  00 00 02 7E
F02:0052       	dc.l	Interrupt	; Unused (reserved)
               S01:000000C8:  00 00 02 7E
F02:0053       	dc.l	Interrupt	; Unused (reserved)
               S01:000000CC:  00 00 02 7E
F02:0054       	dc.l	Interrupt	; Unused (reserved)
               S01:000000D0:  00 00 02 7E
F02:0055       	dc.l	Interrupt	; Unused (reserved)
               S01:000000D4:  00 00 02 7E
F02:0056       	dc.l	Interrupt	; Unused (reserved)
               S01:000000D8:  00 00 02 7E
F02:0057       	dc.l	Interrupt	; Unused (reserved)
               S01:000000DC:  00 00 02 7E
F02:0058       	dc.l	Interrupt	; Unused (reserved)
               S01:000000E0:  00 00 02 7E
F02:0059       	dc.l	Interrupt	; Unused (reserved)
               S01:000000E4:  00 00 02 7E
F02:0060       	dc.l	Interrupt	; Unused (reserved)
               S01:000000E8:  00 00 02 7E
F02:0061       	dc.l	Interrupt	; Unused (reserved)
               S01:000000EC:  00 00 02 7E
F02:0062       	dc.l	Interrupt	; Unused (reserved)
               S01:000000F0:  00 00 02 7E
F02:0063       	dc.l	Interrupt	; Unused (reserved)
               S01:000000F4:  00 00 02 7E
F02:0064       	dc.l	Interrupt	; Unused (reserved)
               S01:000000F8:  00 00 02 7E
F02:0065       	dc.l	Interrupt	; Unused (reserved)
               S01:000000FC:  00 00 02 7E
F02:0066       	
F02:0067       	; Sega string and copyright
F02:0068       	dc.b "SEGA MEGA DRIVE (C)MARC 2004.SEP"
               S01:00000100:  53 45 47 41 20 4D 45 47 41 20 44 52 49 56 45 20
               S01:00000110:  28 43 29 4D 41 52 43 20 32 30 30 34 2E 53 45 50
F02:0069       
F02:0070       	; Domestic name
F02:0071       	;dc.b "MARCS TEST CODE                                 "
F02:0072       	dc.b "Magnus awesome game                             "
               S01:00000120:  4D 61 67 6E 75 73 20 61 77 65 73 6F 6D 65 20 67
               S01:00000130:  61 6D 65 20 20 20 20 20 20 20 20 20 20 20 20 20
F02:0073       
F02:0074       	; Overseas name
F02:0075       	;dc.b "MARCS TEST CODE                                 "
F02:0076       	dc.b "Magnus awesome game                             "
               S01:00000150:  4D 61 67 6E 75 73 20 61 77 65 73 6F 6D 65 20 67
               S01:00000160:  61 6D 65 20 20 20 20 20 20 20 20 20 20 20 20 20
F02:0077       
F02:0078       	; GM (game), product code and serial
F02:0079       	dc.b "GM 12345678-01"
               S01:00000180:  47 4D 20 31 32 33 34 35 36 37 38 2D 30 31
F02:0080       
F02:0081       	; Checksum will be here
F02:0082       	dc.b $81, $B4
               S01:0000018E:  81
               S01:0000018F:  B4
F02:0083       
F02:0084       	; Which devices are supported ?
F02:0085       	dc.b "JD              "
               S01:00000190:  4A 44 20 20 20 20 20 20 20 20 20 20 20 20 20 20
F02:0086       
F02:0087       	; ROM start address
F02:0088       	dc.b $00, $00, $00, $00
               S01:000001A0:  00
               S01:000001A1:  00
               S01:000001A2:  00
               S01:000001A3:  00
F02:0089       
F02:0090       	; ROM end address will be here
F02:0091       	dc.b $00, $02, $00, $00
               S01:000001A4:  00
               S01:000001A5:  02
               S01:000001A6:  00
               S01:000001A7:  00
F02:0092       
F02:0093       	; Some magic values, I don't know what these mean
F02:0094       	dc.b $00, $FF, $00, $00
               S01:000001A8:  00
               S01:000001A9:  FF
               S01:000001AA:  00
               S01:000001AB:  00
F02:0095       	dc.b $00, $FF, $FF, $FF
               S01:000001AC:  00
               S01:000001AD:  FF
               S01:000001AE:  FF
               S01:000001AF:  FF
F02:0096       
F02:0097       	; We don't have a modem, so we fill this with spaces
F02:0098       	dc.b "               "
               S01:000001B0:  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
F02:0099       
F02:0100       	; Unused
F02:0101       	dc.b "                        "
               S01:000001BF:  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
               S01:000001CF:  20 20 20 20 20 20 20 20
F02:0102       	dc.b "                         "
               S01:000001D7:  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
               S01:000001E7:  20 20 20 20 20 20 20 20 20
F02:0103       
F02:0104       	; Country
F02:0105       	dc.b "JUE             "
               S01:000001F0:  4A 55 45 20 20 20 20 20 20 20 20 20 20 20 20 20
F02:0106       
F02:0107       	; dc = define constant
F02:0108       	; ds = define space, hur m√•nga bytes man vill allokera. ds.l 10 allokerar 10 longs
F02:0109       	; rs = definera en struct
F02:0110       
F02:0111       
F02:0112       	org	$200
F02:0113       
F02:0114       
F02:0115       	;
F02:0116       	; Bootup
F02:0117       	;
F02:0118       	; The first attempt was to write a subroutine for each thing we want to do during bootup, to keep the code
F02:0119       	; nice and tidy. There where problems trashing the stack pointer so for simplicity we do everything without
F02:0120       	; subroutines. It's not like we'll reuse the code anyways.
F02:0121       	;
F02:0122       
F02:0123       	;
F02:0124       	; Init the copy protection
F02:0125       	;
F02:0126       	move.b		$A10001,d0					; Read MegaDrive hardware version					| D0 =(0x00A10001)
               S02:00000200:  10 39 00 A1 00 01
F02:0127       	andi.b		#$0F,d0						; The version is stored in last four bytes			| D0 = 0x0000xxxx
               S02:00000206:  02 00 00 0F
F02:0128       	beq			.no_copy_protection			; If they are all zero we've got one the very
               S02:0000020A:  67 0A
F02:0129       											; first MegaDrives which didn't feature the
F02:0130       											; protection
F02:0131       	move.l		#'SEGA',$A14000				; Move the string "SEGA" at 0xA14000
               S02:0000020C:  23 FC 53 45 47 41 00 A1 40 00
F02:0132       .no_copy_protection:
F02:0133       
F02:0134       	;
F02:0135       	; Clear RAM
F02:0136       	;
F02:0137       	;clr.l		d0							; d0 will contain the value we clear the memory with
F02:0138       	move.l		#'FEST',d0
               S02:00000216:  20 3C 46 45 53 54
F02:0139       	move.l		#$3fff,d1					; d1 is the number of long words we will clear. We don't clear the last long since that is the st
               S02:0000021C:  22 3C 00 00 3F FF
F02:0140       	move.l		#$0,a0						; a0 is the address to clear. It starts at 0 and is pre decremented before writing, so that means t
               S02:00000222:  91 C8
F02:0141       .clear_ram_loop:
F02:0142       	move.l		d0,-(a0)					; a0 is decremented by 4, and then 0 is written to the new address
               S02:00000224:  21 00
F02:0143       	dbra		d1,.clear_ram_loop			; decrease d1 by one. If d1 doesn't reach 0 we keep looping
               S02:00000226:  51 C9 FF FC
F02:0144       
F02:0145       	;
F02:0146       	; Init stack pointer
F02:0147       	;
F02:0148       	move.l		#$0,sp						; Set stack pointer to 0, and it decrements so the first long value will be stored at $fffffc (decr
               S02:0000022A:  9F CF
F02:0149       
F02:0150       	bsr			inpInit
               S02:0000022C:  61 00 04 70
F02:0151       	jsr			rendInit
               S02:00000230:  61 00 04 B4
F02:0152       
F02:0153       	;
F02:0154       	; Enable interrupts
F02:0155       	;
F02:0156       	move.l		#0,(VarVsync)
               S02:00000234:  23 FC 00 00 00 00 00 FF E0 00
F02:0157       	move.l		#0,(VarHsync)
               S02:0000023E:  23 FC 00 00 00 00 00 FF E0 04
F02:0158       	move.w		#$2400,sr
               S02:00000248:  46 FC 24 00
F02:0159       
F02:0160       	move.l		#$11111111,d0
               S02:0000024C:  20 3C 11 11 11 11
F02:0161       	move.l		#$22222222,d1
               S02:00000252:  22 3C 22 22 22 22
F02:0162       	move.l		#$33333333,d2
               S02:00000258:  24 3C 33 33 33 33
F02:0163       	move.l		#$44444444,d3
               S02:0000025E:  26 3C 44 44 44 44
F02:0164       	move.l		#$55555555,d4
               S02:00000264:  28 3C 55 55 55 55
F02:0165       	move.l		#$66666666,d5
               S02:0000026A:  2A 3C 66 66 66 66
F02:0166       	move.l		#$77777777,d6
               S02:00000270:  2C 3C 77 77 77 77
F02:0167       	move.l		#$88888888,d7
               S02:00000276:  2E 3C 88 88 88 88
F02:0168       
F02:0169       	jsr			main
               S02:0000027C:  61 12
F02:0170       
F02:0171       ;==============================================================================
F02:0172       ;
F02:0173       ; Interrupt routines
F02:0174       ;
F02:0175       ;==============================================================================
F02:0176       Interrupt:
F02:0177       	rte
               S02:0000027E:  4E 73
F02:0178       	
F02:0179       HBlankInterrupt:
F02:0180       	add.l		#1,(VarHsync)
               S02:00000280:  52 B9 00 FF E0 04
F02:0181       	rte
               S02:00000286:  4E 73
F02:0182       
F02:0183       VBlankInterrupt:
F02:0184       	add.l		#1,(VarVsync)
               S02:00000288:  52 B9 00 FF E0 00
F02:0185       	rte
               S02:0000028E:  4E 73
F02:0186       
F00:0006       	include		"../src/structs.asm"
F03:0001       
F00:0007       	include		"../src/macros.asm"
F04:0001       ;==================================================================================================
F04:0002       ;
F04:0003       ; Macros to push and pop to the stack
F04:0004       ;
F04:0005       ;==================================================================================================
F04:0006       ;
F04:0007       ; Will decrement the stack pointer and write a register to the new address
F04:0008       ;
F04:0009       ; Usage:
F04:0010       ; push		d0
F04:0011       ;
F04:0012       push			MACRO
F04:0014       
F04:0015       
F04:0016       pushm			MACRO
F04:0018       
F04:0019       
F04:0020       ;
F04:0021       ; Will write a value from the current stack address into a register, and then increment the stack pointer
F04:0022       ;
F04:0023       ; Usage:
F04:0024       ; pop		d0
F04:0025       ;
F04:0026       pop				MACRO
F04:0028       
F04:0029       
F04:0030       popm			MACRO
F04:0032       
F04:0033       
F04:0034       
F04:0035       ;==================================================================================================
F04:0036       ;
F04:0037       ; Stack macros that treat the stack like a small piece of memory that
F04:0038       ; you can freely write to and read from in any order you'd like.
F04:0039       ;
F04:0040       ;==================================================================================================
F04:0041       ;
F04:0042       ;
F04:0043       ; Allocates X bytes on the stack.
F04:0044       ;
F04:0045       ; Usage:
F04:0046       ; stack_alloc	8		; Will allocate 8 bytes on the stack
F04:0047       ; stack_alloc	$20		; Will allocate 32 bytes on the stack
F04:0048       ;
F04:0049       stack_alloc		MACRO
F04:0051       
F04:0052       
F04:0053       ;
F04:0054       ; Free X bytes on the stack.
F04:0055       ;
F04:0056       ; Usage:
F04:0057       ; stack_free	8		; Will free 8 bytes from the stack
F04:0058       ; stack_free	$20		; Will free 32 bytes from the stack
F04:0059       ;
F04:0060       stack_free		MACRO
F04:0062       
F04:0063       
F04:0064       ;
F04:0065       ; Write a register to an address with a specified offset relative to the stack. This is
F04:0066       ; to get around the specific order of pushing and popping that is otherwise needed.
F04:0067       ;
F04:0068       ; Can only be used after a stack_alloc and isn't allowed
F04:0069       ; to write to more bytes than what was allocated
F04:0070       ;
F04:0071       ; mnemonic extension is supported.
F04:0072       ;
F04:0073       ; Usage:
F04:0074       ; stack_write	d0,0		; Will write d0 to sp+0
F04:0075       ; stack_write	d0,4		; Will write d0 to sp+4
F04:0076       ; stack_write.b	d0,0		; Will write the lowest byte of d0 into sp+0
F04:0077       ;
F04:0078       ;
F04:0079       stack_write		MACRO
F04:0081       
F04:0082       
F04:0083       ;
F04:0084       ; Read from the stack with an offset into the specified register. This is to get
F04:0085       ; around the specific order of pushing and popping that is otherwise needed.
F04:0086       ;
F04:0087       ; Can only be used after a stack_alloc and isn't allowed
F04:0088       ; to write to more bytes than what was allocated
F04:0089       ;
F04:0090       ; mnemonic extension is supported.
F04:0091       ;
F04:0092       ; Usage:
F04:0093       ; stack_read	d0,0		; Will read from sp+0 and write into d0
F04:0094       ; stack_read	d0,4		; Will read from sp+04 and write into d0
F04:0095       ; stack_read.b	d0,0		; Will read lowest byte from sp+0 and write into lowest byte of d0
F04:0096       ;
F04:0097       stack_read		MACRO
F04:0099       
F04:0100       
F00:0008       	include		"../src/main.asm"
F05:0001       screen_width				equ			320
F05:0002       screen_height				equ			224
F05:0003       
F05:0004       room_width					equ			512
F05:0005       room_height					equ			512
F05:0006       
F05:0007       camera_padding_horizontal	equ			96
F05:0008       camera_padding_vertical		equ			64
F05:0009       
F05:0010       	rsreset
F05:0011       _hero_go_handle				rs.l		1
F05:0012       _hero_sprite_pos_x			rs.w		1
F05:0013       _hero_sprite_pos_y			rs.w		1
F05:0014       _camera_pos_x				rs.w		1
F05:0015       _camera_pos_y				rs.w		1
F05:0016       _potion_go_handle			rs.w		1
F05:0017       _testanim_time				rs.w		1
F05:0018       _potion2_go_handle			rs.w		1
F05:0019       _potion3_go_handle			rs.w		1
F05:0020       _potion4_go_handle			rs.w		1
F05:0021       _potionanim_time			rs.w		1
F05:0022       
F05:0023       
F05:0024       main:
F05:0025       	jsr			gomInit(pc)
               S02:00000290:  4E BA 02 76
F05:0026       
F05:0027       	;
F05:0028       	jsr			memGetUserBaseAddress(pc)	;
               S02:00000294:  4E BA 02 62
F05:0029       	move.l		a0,a2						; a2 will be user mem from now on
               S02:00000298:  24 48
F05:0030       	lea			sintable(pc),a3				; a3 will be sinus table
               S02:0000029A:  47 FA 08 7C
F05:0031       
F05:0032       	;
F05:0033       	; Setup local variables
F05:0034       	;
F05:0035       	move		#0,_hero_sprite_pos_x(a2)
               S02:0000029E:  35 7C 00 00 00 04
F05:0036       	move		#0,_hero_sprite_pos_y(a2)
               S02:000002A4:  35 7C 00 00 00 06
F05:0037       	move		#0,_camera_pos_x(a2)
               S02:000002AA:  35 7C 00 00 00 08
F05:0038       	move		#0,_camera_pos_y(a2)
               S02:000002B0:  35 7C 00 00 00 0A
F05:0039       
F05:0040       	;
F05:0041       	move		#0,_testanim_time(a2)
               S02:000002B6:  35 7C 00 00 00 0E
F05:0042       	move.w		#0,_potionanim_time(a2)
               S02:000002BC:  35 7C 00 00 00 16
F05:0043       
F05:0044       	;
F05:0045       	; Load world graphics
F05:0046       	;
F05:0047       	move.l		#fileid_testtiles_palette,d0
               S02:000002C2:  70 0E
F05:0048       	moveq		#0,d1
               S02:000002C4:  72 00
F05:0049       	jsr			rendLoadPalette(pc)
               S02:000002C6:  4E BA 06 AE
F05:0050       
F05:0051       	ifd is_amiga
F05:0052       	move.l		#fileid_testsprite_palette,d0
F05:0053       	moveq		#1,d1
F05:0054       	jsr			rendLoadPalette(pc)
F05:0055       	endif
F05:0056       
F05:0057       	move.l		#fileid_testtiles_bank,d0
               S02:000002CA:  70 0C
F05:0058       	jsr			rendLoadTileBank(pc)
               S02:000002CC:  4E BA 04 BA
F05:0059       
F05:0060       	move.l		#fileid_testmap_map,d0
               S02:000002D0:  70 1B
F05:0061       	move.l		#0,d1
               S02:000002D2:  72 00
F05:0062       	jsr			rendLoadTileMap(pc)
               S02:000002D4:  4E BA 06 20
F05:0063       
F05:0064       	;
F05:0065       	; Load the potion game object
F05:0066       	;
F05:0067       	lea			potion_go(pc),a0
               S02:000002D8:  41 FA 0A 4E
F05:0068       	jsr			gomLoadObject(pc)
               S02:000002DC:  4E BA 02 4C
F05:0069       	move.l		d0,_potion_go_handle(a2)
               S02:000002E0:  25 40 00 0C
F05:0070       
F05:0071       	;
F05:0072       	; Load the hero game object
F05:0073       	;
F05:0074       	lea			hero_go(pc),a0
               S02:000002E4:  41 FA 0A 3E
F05:0075       	jsr			gomLoadObject(pc)
               S02:000002E8:  4E BA 02 40
F05:0076       	move.l		d0,_hero_go_handle(a2)
               S02:000002EC:  24 80
F05:0077       
F05:0078       	;
F05:0079       	; Load more the potions
F05:0080       	;
F05:0081       	lea			potion_go(pc),a0
               S02:000002EE:  41 FA 0A 38
F05:0082       	jsr			gomLoadObject(pc)
               S02:000002F2:  4E BA 02 36
F05:0083       	move.w		d0,_potion2_go_handle(a2)
               S02:000002F6:  35 40 00 10
F05:0084       
F05:0085       	;
F05:0086       	; Load more the potions
F05:0087       	;
F05:0088       	lea			potion_go(pc),a0
               S02:000002FA:  41 FA 0A 2C
F05:0089       	jsr			gomLoadObject(pc)
               S02:000002FE:  4E BA 02 2A
F05:0090       	move.w		d0,_potion3_go_handle(a2)
               S02:00000302:  35 40 00 12
F05:0091       
F05:0092       	;
F05:0093       	; Load more the potions
F05:0094       	;
F05:0095       	lea			potion_go(pc),a0
               S02:00000306:  41 FA 0A 20
F05:0096       	jsr			gomLoadObject(pc)
               S02:0000030A:  4E BA 02 1E
F05:0097       	move.w		d0,_potion4_go_handle(a2)
               S02:0000030E:  35 40 00 14
F05:0098       
F05:0099       .main_loop:
F05:0100       	;
F05:0101       	; Read player input and update player world positions
F05:0102       	;
F05:0103       	bsr			_inputUpdate
               S02:00000312:  61 00 00 E2
F05:0104       	bsr			_checkBorders
               S02:00000316:  61 00 01 B2
F05:0105       
F05:0106       	;
F05:0107       	; Update hero position with the game object manager
F05:0108       	;
F05:0109       	move.l		_hero_go_handle(a2),d0
               S02:0000031A:  20 12
F05:0110       	move.w		_hero_sprite_pos_x(a2),d1
               S02:0000031C:  32 2A 00 04
F05:0111       	move.w		_hero_sprite_pos_y(a2),d2
               S02:00000320:  34 2A 00 06
F05:0112       	jsr			gomSetPosition(pc)
               S02:00000324:  4E BA 02 60
F05:0113       
F05:0114       	;
F05:0115       	move.w		_potion_go_handle(a2),d0	; d0 is game object handle
               S02:00000328:  30 2A 00 0C
F05:0116       	move.w		_potionanim_time(a2),d3
               S02:0000032C:  36 2A 00 16
F05:0117       	lsl.w		#1,d3
               S02:00000330:  E3 4B
F05:0118       	move.w		#30,d1						; d1 is world X position
               S02:00000332:  32 3C 00 1E
F05:0119       	move.w		(a3,d3),d2					; d2 is world Y position, from sin table. Can be negative.
               S02:00000336:  34 33 30 00
F05:0120       	asr.w		#3,d2
               S02:0000033A:  E6 42
F05:0121       	add.w		#100,d2
               S02:0000033C:  D4 7C 00 64
F05:0122       	jsr			gomSetPosition(pc)
               S02:00000340:  4E BA 02 44
F05:0123       
F05:0124       	move.w		_potion2_go_handle(a2),d0	; d0 is game object handle
               S02:00000344:  30 2A 00 10
F05:0125       	add.w		#30,d3
               S02:00000348:  D6 7C 00 1E
F05:0126       	and.w		#$1ff,d3
               S02:0000034C:  C6 7C 01 FF
F05:0127       	add.w		#8,d1						; d1 is world X position
               S02:00000350:  50 41
F05:0128       	move.w		(a3,d3),d2					; d2 is world Y position, from sin table. Can be negative.
               S02:00000352:  34 33 30 00
F05:0129       	asr.w		#3,d2
               S02:00000356:  E6 42
F05:0130       	add.w		#100,d2
               S02:00000358:  D4 7C 00 64
F05:0131       	jsr			gomSetPosition(pc)
               S02:0000035C:  4E BA 02 28
F05:0132       
F05:0133       	move.w		_potion3_go_handle(a2),d0	; d0 is game object handle
               S02:00000360:  30 2A 00 12
F05:0134       	add.w		#30,d3
               S02:00000364:  D6 7C 00 1E
F05:0135       	and.w		#$1ff,d3
               S02:00000368:  C6 7C 01 FF
F05:0136       	add.w		#8,d1						; d1 is world X position
               S02:0000036C:  50 41
F05:0137       	move.w		(a3,d3),d2					; d2 is world Y position, from sin table. Can be negative.
               S02:0000036E:  34 33 30 00
F05:0138       	asr.w		#3,d2
               S02:00000372:  E6 42
F05:0139       	add.w		#100,d2
               S02:00000374:  D4 7C 00 64
F05:0140       	jsr			gomSetPosition(pc)
               S02:00000378:  4E BA 02 0C
F05:0141       
F05:0142       	move.w		_potion4_go_handle(a2),d0	; d0 is game object handle
               S02:0000037C:  30 2A 00 14
F05:0143       	add.w		#30,d3
               S02:00000380:  D6 7C 00 1E
F05:0144       	and.w		#$1ff,d3
               S02:00000384:  C6 7C 01 FF
F05:0145       	add.w		#8,d1						; d1 is world X position
               S02:00000388:  50 41
F05:0146       	move.w		(a3,d3),d2					; d2 is world Y position, from sin table. Can be negative.
               S02:0000038A:  34 33 30 00
F05:0147       	asr.w		#3,d2
               S02:0000038E:  E6 42
F05:0148       	add.w		#100,d2
               S02:00000390:  D4 7C 00 64
F05:0149       	jsr			gomSetPosition(pc)
               S02:00000394:  4E BA 01 F0
F05:0150       
F05:0151       
F05:0152       
F05:0153       
F05:0154       	;
F05:0155       	; Update camera so the player doesn't go out of bounds
F05:0156       	;
F05:0157       	bsr			_cameraUpdate
               S02:00000398:  61 00 00 B2
F05:0158       
F05:0159       	;
F05:0160       	; Update camera position with the game object manager
F05:0161       	;
F05:0162       	move		_camera_pos_x(a2),d0
               S02:0000039C:  30 2A 00 08
F05:0163       	move		_camera_pos_y(a2),d1
               S02:000003A0:  32 2A 00 0A
F05:0164       	jsr			gomSetCameraPosition(pc)
               S02:000003A4:  4E BA 01 F4
F05:0165       
F05:0166       	perf_stop
F06:0001       	move.w		#$8701,($00C00004)
               S02:000003A8:  33 FC 87 01 00 C0 00 04
F05:0167       	jsr			rendWaitVSync(pc)
               S02:000003B0:  4E BA 03 8E
F05:0168       	perf_start
F07:0001       	move.w		#$8700,($00C00004)
               S02:000003B4:  33 FC 87 00 00 C0 00 04
F05:0169       
F05:0170       	jsr			gomSortObjects(pc)
               S02:000003BC:  4E BA 02 3A
F05:0171       	jsr			gomRender(pc)
               S02:000003C0:  4E BA 01 E6
F05:0172       
F05:0173       
F05:0174       	;
F05:0175       	; Slow loop to test performance thingie
F05:0176       	;
F05:0177       ;	move.l		#8000,d1
F05:0178       ;.perf_loop_test:
F05:0179       ;	dbra		d1,.perf_loop_test
F05:0180       
F05:0181       	;
F05:0182       	; Update animation
F05:0183       	;
F05:0184       	move.w		_potion_go_handle(a2),d0
               S02:000003C4:  30 2A 00 0C
F05:0185       	;move.w		_go_sprite_handle
F05:0186       	move.w		_testanim_time(a2),d1
               S02:000003C8:  32 2A 00 0E
F05:0187       	lsr			#4,d1
               S02:000003CC:  E8 49
F05:0188       	and			#1,d1
               S02:000003CE:  C2 7C 00 01
F05:0189       	jsr			rendSetSpriteFrame(pc)
               S02:000003D2:  4E BA 04 F0
F05:0190       
F05:0191       	;
F05:0192       	; Increment animation time
F05:0193       	;
F05:0194       	move.w		_testanim_time(a2),d0
               S02:000003D6:  30 2A 00 0E
F05:0195       	add.w		#1,d0
               S02:000003DA:  52 40
F05:0196       	and.w		#$ff,d0
               S02:000003DC:  C0 7C 00 FF
F05:0197       	move.w		d0,_testanim_time(a2)
               S02:000003E0:  35 40 00 0E
F05:0198       
F05:0199       	;
F05:0200       	; Increment potion animation time
F05:0201       	;
F05:0202       	move.w		_potionanim_time(a2),d0
               S02:000003E4:  30 2A 00 16
F05:0203       	add.w		#1,d0
               S02:000003E8:  52 40
F05:0204       	and.w		#$ff,d0
               S02:000003EA:  C0 7C 00 FF
F05:0205       	move.w		d0,_potionanim_time(a2)
               S02:000003EE:  35 40 00 16
F05:0206       
F05:0207       
F05:0208       	;
F05:0209       	bra			.main_loop
               S02:000003F2:  60 00 FF 1E
F05:0210       
F05:0211       
F05:0212       
F05:0213       
F05:0214       ;
F05:0215       ; Ask hardware for the input and act on it
F05:0216       ;
F05:0217       _inputUpdate:
F05:0218       	jsr			inpUpdate(pc)				; Return the currently pressed buttons in d0
               S02:000003F6:  4E BA 02 CA
F05:0219       
F05:0220       	btst		#INPUT_ACTION,d0
               S02:000003FA:  08 00 00 06
F05:0221       	beq			.change_picture_0
               S02:000003FE:  67 38
F05:0222       
F05:0223       	btst		#INPUT_ACTION2,d0
               S02:00000400:  08 00 00 04
F05:0224       	beq			.change_picture_1
               S02:00000404:  67 3C
F05:0225       
F05:0226       	btst		#INPUT_LEFT,d0
               S02:00000406:  08 00 00 02
F05:0227       	beq			.scroll_left
               S02:0000040A:  67 08
F05:0228       
F05:0229       	btst		#INPUT_RIGHT,d0
               S02:0000040C:  08 00 00 03
F05:0230       	beq			.scroll_right
               S02:00000410:  67 08
F05:0231       
F05:0232       	bra			.scroll_updown
               S02:00000412:  60 0A
F05:0233       
F05:0234       .scroll_left:
F05:0235       	subq.w		#1,_hero_sprite_pos_x(a2)
               S02:00000414:  53 6A 00 04
F05:0236       	bra			.scroll_updown
               S02:00000418:  60 04
F05:0237       
F05:0238       .scroll_right:
F05:0239       	addq.w		#1,_hero_sprite_pos_x(a2)
               S02:0000041A:  52 6A 00 04
F05:0240       	bra			.scroll_updown
F05:0241       
F05:0242       .scroll_updown:
F05:0243       	btst		#INPUT_UP,d0
               S02:0000041E:  08 00 00 00
F05:0244       	beq			.scroll_up
               S02:00000422:  67 08
F05:0245       
F05:0246       	btst		#INPUT_DOWN,d0
               S02:00000424:  08 00 00 01
F05:0247       	beq			.scroll_down
               S02:00000428:  67 08
F05:0248       
F05:0249       	bra			.done
               S02:0000042A:  60 1E
F05:0250       
F05:0251       .scroll_up:
F05:0252       	subq.w		#1,_hero_sprite_pos_y(a2)
               S02:0000042C:  53 6A 00 06
F05:0253       	bra			.done
               S02:00000430:  60 18
F05:0254       
F05:0255       .scroll_down:
F05:0256       	addq.w		#1,_hero_sprite_pos_y(a2)
               S02:00000432:  52 6A 00 06
F05:0257       	bra			.done
               S02:00000436:  60 12
F05:0258       
F05:0259       .change_picture_0
F05:0260       	lea			testtiles_image(pc),a0
               S02:00000438:  41 FA 08 DE
F05:0261       	bsr.w		imgLoad
               S02:0000043C:  61 00 06 AA
F05:0262       	bra			.done
               S02:00000440:  60 08
F05:0263       
F05:0264       .change_picture_1
F05:0265       	lea			untitled_splash_image(pc),a0
               S02:00000442:  41 FA 08 DA
F05:0266       	bsr.w		imgLoad
               S02:00000446:  61 00 06 A0
F05:0267       	bra			.done
F05:0268       
F05:0269       .done:
F05:0270       	; As it is now all the branches to done could be an rts instead,
F05:0271       	; but in case we want to clean something up it's better to have
F05:0272       	; closure to the function so we're prepared.
F05:0273       	rts
               S02:0000044A:  4E 75
F05:0274       
F05:0275       
F05:0276       
F05:0277       ;
F05:0278       ; Updates the camera. The camera will follow the
F05:0279       ; player sprite around, but not go out of bounds
F05:0280       ;
F05:0281       _cameraUpdate:
F05:0282       	move		_camera_pos_x(a2),d0
               S02:0000044C:  30 2A 00 08
F05:0283       	move		_hero_sprite_pos_x(a2),d1
               S02:00000450:  32 2A 00 04
F05:0284       
F05:0285       	;
F05:0286       	; Check if player is too far left
F05:0287       	;
F05:0288       	sub			d0,d1								; d2 = CameraX - HeroSpriteX		(30-40=10 pixels to the left)
               S02:00000454:  92 40
F05:0289       	sub			#camera_padding_horizontal,d1		; delta -= padding					(10-32=-22)
               S02:00000456:  92 7C 00 60
F05:0290       	cmp			#0,d1								;
               S02:0000045A:  4A 41
F05:0291       	bge			.no_adjust_left
               S02:0000045C:  6C 0E
F05:0292       	add			d1,d0
               S02:0000045E:  D0 41
F05:0293       
F05:0294       	; Now when we've adjust the camera to the left we need to make sure it isn't too far off to the left
F05:0295       	cmp			#0,d0
               S02:00000460:  4A 40
F05:0296       	bge			.left_ok
               S02:00000462:  6C 02
F05:0297       	clr			d0
               S02:00000464:  42 40
F05:0298       .left_ok:
F05:0299       	move		d0,_camera_pos_x(a2)		; If we need to adjust the camera then d2 will be a negative value, hence moving the camera
               S02:00000466:  35 40 00 08
F05:0300       	bra			.check_vertical_adjust
               S02:0000046A:  60 1E
F05:0301       
F05:0302       .no_adjust_left:
F05:0303       	move		_hero_sprite_pos_x(a2),d1
               S02:0000046C:  32 2A 00 04
F05:0304       
F05:0305       
F05:0306       	;
F05:0307       	; Check if player is too far to the right
F05:0308       	;
F05:0309       
F05:0310       	;
F05:0311       	; CameraX = 10
F05:0312       	; Camera width = 320
F05:0313       	; PlayerX = 340
F05:0314       	; Then player is 10 pixels off screen to the right
F05:0315       	; PlayerX-CameraX-CameraWidth=10
F05:0316       	;
F05:0317       	;
F05:0318       	;
F05:0319       
F05:0320       	sub			d0,d1													; d2 = CameraX - HeroSpriteX		(30-40=10 pixels to the left)
               S02:00000470:  92 40
F05:0321       	sub			#screen_width-camera_padding_horizontal-16,d1			; delta -= padding					(10-32=-22)
               S02:00000472:  92 7C 00 D0
F05:0322       	cmp			#0,d1													;
               S02:00000476:  4A 41
F05:0323       	ble			.no_adjust_right
               S02:00000478:  6F 10
F05:0324       	add			d1,d0
               S02:0000047A:  D0 41
F05:0325       
F05:0326       	; Now when we've adjust the camera to the left we need to make sure it isn't too far off to the left
F05:0327       	cmp			#room_width-screen_width,d0
               S02:0000047C:  B0 7C 00 C0
F05:0328       	ble			.right_ok
               S02:00000480:  6F 04
F05:0329       	move		#room_width-screen_width,d0
               S02:00000482:  30 3C 00 C0
F05:0330       .right_ok:
F05:0331       	move		d0,_camera_pos_x(a2)		; If we need to adjust the camera then d2 will be a negative value, hence moving the camera
               S02:00000486:  35 40 00 08
F05:0332       .no_adjust_right:
F05:0333       
F05:0334       
F05:0335       
F05:0336       
F05:0337       .check_vertical_adjust:
F05:0338       	move		_camera_pos_y(a2),d0
               S02:0000048A:  30 2A 00 0A
F05:0339       	move		_hero_sprite_pos_y(a2),d1
               S02:0000048E:  32 2A 00 06
F05:0340       
F05:0341       	;
F05:0342       	; Check if player is too far left
F05:0343       	;
F05:0344       	sub			d0,d1							; d2 = CameraX - HeroSpriteX		(30-40=10 pixels to the left)
               S02:00000492:  92 40
F05:0345       	sub			#camera_padding_vertical,d1		; delta -= padding					(10-32=-22)
               S02:00000494:  92 7C 00 40
F05:0346       	cmp			#0,d1							;
               S02:00000498:  4A 41
F05:0347       	bge			.no_adjust_up
               S02:0000049A:  6C 0E
F05:0348       	add			d1,d0
               S02:0000049C:  D0 41
F05:0349       
F05:0350       	; Now when we've adjust the camera to the left we need to make sure it isn't too far off to the left
F05:0351       	cmp			#0,d0
               S02:0000049E:  4A 40
F05:0352       	bge			.up_ok
               S02:000004A0:  6C 02
F05:0353       	clr			d0
               S02:000004A2:  42 40
F05:0354       .up_ok:
F05:0355       	move		d0,_camera_pos_y(a2)		; If we need to adjust the camera then d2 will be a negative value, hence moving the camera
               S02:000004A4:  35 40 00 0A
F05:0356       	bra			.done
               S02:000004A8:  60 1E
F05:0357       
F05:0358       .no_adjust_up:
F05:0359       	move		_hero_sprite_pos_y(a2),d1
               S02:000004AA:  32 2A 00 06
F05:0360       
F05:0361       
F05:0362       	;
F05:0363       	; Check if player is too far to the right
F05:0364       	;
F05:0365       
F05:0366       	;
F05:0367       	; CameraX = 10
F05:0368       	; Camera width = 320
F05:0369       	; PlayerX = 340
F05:0370       	; Then player is 10 pixels off screen to the right
F05:0371       	; PlayerX-CameraX-CameraWidth=10
F05:0372       	;
F05:0373       	;
F05:0374       	;
F05:0375       
F05:0376       	sub			d0,d1													; d2 = CameraX - HeroSpriteX		(30-40=10 pixels to the left)
               S02:000004AE:  92 40
F05:0377       	sub			#screen_height-camera_padding_vertical-16,d1			; delta -= padding					(10-32=-22)
               S02:000004B0:  92 7C 00 90
F05:0378       	cmp			#0,d1													;
               S02:000004B4:  4A 41
F05:0379       	ble			.no_adjust_down
               S02:000004B6:  6F 10
F05:0380       	add			d1,d0
               S02:000004B8:  D0 41
F05:0381       
F05:0382       	; Now when we've adjust the camera to the left we need to make sure it isn't too far off to the left
F05:0383       	cmp			#room_height-screen_height,d0
               S02:000004BA:  B0 7C 01 20
F05:0384       	ble			.down_ok
               S02:000004BE:  6F 04
F05:0385       	move		#room_height-screen_height,d0
               S02:000004C0:  30 3C 01 20
F05:0386       .down_ok:
F05:0387       	move		d0,_camera_pos_y(a2)		; If we need to adjust the camera then d2 will be a negative value, hence moving the camera
               S02:000004C4:  35 40 00 0A
F05:0388       .no_adjust_down:
F05:0389       
F05:0390       
F05:0391       .done:
F05:0392       	rts
               S02:000004C8:  4E 75
F05:0393       
F05:0394       
F05:0395       _checkBorders:
F05:0396       	move.w		_hero_sprite_pos_x(a2),d0
               S02:000004CA:  30 2A 00 04
F05:0397       	cmp.w		#0,d0
               S02:000004CE:  4A 40
F05:0398       	bge			.no_left
               S02:000004D0:  6C 10
F05:0399       
F05:0400       	;
F05:0401       	; Load room to the left
F05:0402       	;
F05:0403       	move.l		#fileid_testmap_map,d0
               S02:000004D2:  70 1B
F05:0404       	move.l		#0,d1
               S02:000004D4:  72 00
F05:0405       	jsr			rendLoadTileMap(pc)
               S02:000004D6:  4E BA 04 1E
F05:0406       
F05:0407       	;
F05:0408       	; Warp hero to the right of the new map
F05:0409       	;
F05:0410       	move.w		#511-16,_hero_sprite_pos_x(a2)
               S02:000004DA:  35 7C 01 EF 00 04
F05:0411       
F05:0412       	; Done
F05:0413       	bra			.done
               S02:000004E0:  60 14
F05:0414       
F05:0415       .no_left:
F05:0416       	cmp.w		#511-16,d0
               S02:000004E2:  B0 7C 01 EF
F05:0417       	ble			.no_right
               S02:000004E6:  6F 0E
F05:0418       
F05:0419       	;
F05:0420       	; Load room to the right
F05:0421       	;
F05:0422       	move.l		#fileid_testmap2_map,d0
               S02:000004E8:  70 1C
F05:0423       	move.l		#0,d1
               S02:000004EA:  72 00
F05:0424       	jsr			rendLoadTileMap(pc)
               S02:000004EC:  4E BA 04 08
F05:0425       
F05:0426       	;
F05:0427       	; Warp hero to the left of the new map
F05:0428       	;
F05:0429       	move.w		#0,_hero_sprite_pos_x(a2)
               S02:000004F0:  35 7C 00 00 00 04
F05:0430       
F05:0431       .no_right:
F05:0432       .done:
F05:0433       	rts
               S02:000004F6:  4E 75
F05:0434       
F00:0009       	include		"../src/core/mem.asm"
F08:0001       ;==================================================================================================
F08:0002       ;
F08:0003       ; RAM Memory map for shared code. Platform specific code is not included in this
F08:0004       ;
F08:0005       ;==================================================================================================
F08:0006       totalmem_size		=	$e000			; This is the total amount of RAM allocated for the shared
F08:0007       										; code. The total size of all other areas must not be
F08:0008       										; greater than this size. Also, the Mega Drive only have
F08:0009       										; 64KB RAM so the totalmem_size and all platform specific
F08:0010       										; memory most not be greater than $ffff
F08:0011       
F08:0012       ; Game logic etc..
F08:0013       usermem_base		=	$0000
F08:0014       usermem_size		=	$0100
F08:0015       usermem_end			=	usermem_size
F08:0016       
F08:0017       ; Game Object Manager
F08:0018       gommem_base			= 	usermem_size
F08:0019       gommem_size			=	$0100
F08:0020       gommem_end			=	gommem_base+gommem_size
F08:0021       
F08:0022       ;==================================================================================================
F08:0023       ;
F08:0024       ; Get the address of different memory spaces
F08:0025       ;
F08:0026       ;==================================================================================================
F08:0027       memGetUserBaseAddress:
F08:0028       	jsr				memGetPlatformBase(pc)
               S02:000004F8:  4E BA 01 9C
F08:0029       	add.l			#usermem_base,a0
F08:0030       	rts
               S02:000004FC:  4E 75
F08:0031       
F08:0032       memGetGameObjectManagerBaseAddress:
F08:0033       	jsr				memGetPlatformBase(pc)
               S02:000004FE:  4E BA 01 96
F08:0034       	add.l			#gommem_base,a0
               S02:00000502:  41 E8 01 00
F08:0035       	rts
               S02:00000506:  4E 75
F08:0036       
F00:0010       	include		"../src/core/gameobjectmanager.asm"
F09:0001       ;==============================================================================
F09:0002       ;
F09:0003       ; The Game Object manager is a layer between the game logic and the
F09:0004       ; rendering hardware.
F09:0005       ;
F09:0006       ; This layer handles things like loading hardware sprites, updating
F09:0007       ; animations on game objects, doing world to screen transform before
F09:0008       ; rendering etc.
F09:0009       ;
F09:0010       ; Should it also resolve physics etc? If it holds the world position
F09:0011       ; of game objects, and the interface to change the world position is
F09:0012       ; through this, does that mean this should also handle collision?
F09:0013       ;
F09:0014       ; Maybe!
F09:0015       ;
F09:0016       ;==============================================================================
F09:0017       
F09:0018       _gom_max_objects	equ			40		; Maximum number of game objects in a room at any given time
F09:0019       
F09:0020       
F09:0021       ;
F09:0022       ; The properties of an individual game object
F09:0023       ;
F09:0024       	rsreset
F09:0025       _go_world_pos_x		rs.w		1							; Game object world X position
F09:0026       _go_world_pos_y		rs.w		1							; Game object world Y position
F09:0027       _go_sprite_handle	rs.w		1							; Hardware sprite handle for the associated sprite
F09:0028       _go_anim_time		rs.w		1							; Current animation time
F09:0029       _go_sort			rs.w		1							; Sort value for object compared to other objects. Haven't decided if lower sort means drawn be
F09:0030       _go_size			rs.w		0
F09:0031       
F09:0032       ;
F09:0033       ; The state variables of the game object manager
F09:0034       ;
F09:0035       	rsreset
F09:0036       _gom_numobjects			rs.w		1							; How many objects we currently have loaded. This increments for each loaded game object
F09:0037       _gom_watermark			rs.w		1							; To unload game objects
F09:0038       _gom_camera_x			rs.w		1							; Camera world X position, so we can do world to screen transform
F09:0039       _gom_camera_y			rs.w		1							; Camera world Y position, same reason as above
F09:0040       _gom_gameobjects		rs.b		_gom_max_objects*_go_size	; All game objects goes here
F09:0041       _gom_draworder			rs.b		_gom_max_objects			; This table describe which game object to draw when. First entry should be dr
F09:0042       _gom_debug_a			rs.b		1
F09:0043       _gom_draworder_sprites	rs.b		_gom_max_objects			; Before we send the draw order table to the renderer we need to convert
F09:0044       _gom_debug_b			rs.b		1
F09:0045       _gom_size				rs.w		0
F09:0046       
F09:0047       ;==============================================================================
F09:0048       ;
F09:0049       ; Game Object Manager Init
F09:0050       ;
F09:0051       ; Setup the default state of the game object manager
F09:0052       ;
F09:0053       ; Input
F09:0054       ;	None
F09:0055       ;
F09:0056       ; Output
F09:0057       ;	None
F09:0058       ;
F09:0059       ;==============================================================================
F09:0060       
F09:0061       gomInit:
F09:0062       	jsr			memGetGameObjectManagerBaseAddress(pc)
               S02:00000508:  4E BA FF F4
F09:0063       
F09:0064       	;	
F09:0065       	; Clear all local variables
F09:0066       	;
F09:0067       	move.l		#(_gom_size/4)-1,d0
               S02:0000050C:  70 79
F09:0068       .loop:
F09:0069       	move.l		#0,(a0)+
               S02:0000050E:  20 FC 00 00 00 00
F09:0070       	dbra		d0,.loop
               S02:00000514:  51 C8 FF F8
F09:0071       
F09:0072       	; Set debug stuff
F09:0073       	jsr			memGetGameObjectManagerBaseAddress(pc)
               S02:00000518:  4E BA FF E4
F09:0074       	move.b		#$ff,_gom_debug_a(a0)
               S02:0000051C:  11 7C 00 FF 01 C0
F09:0075       	move.b		#$ff,_gom_debug_b(a0)
               S02:00000522:  11 7C 00 FF 01 E9
F09:0076       
F09:0077       	rts
               S02:00000528:  4E 75
F09:0078       
F09:0079       
F09:0080       ;==============================================================================
F09:0081       ;
F09:0082       ; Loads a game object and set up all the state variables needed
F09:0083       ;
F09:0084       ; Input
F09:0085       ;	a0=address pointing at static game object data
F09:0086       ;
F09:0087       ; Output
F09:0088       ;	d0=handle to the game object
F09:0089       ;
F09:0090       ;==============================================================================
F09:0091       
F09:0092       gomLoadObject:
F09:0093       	pushm.l				d2-d3
F10:0001       	movem.l		d2-d3,-(sp)
               S02:0000052A:  48 E7 30 00
F09:0094       	; First we load the sprite, while the registers are untouched
F09:0095       	clr					d0
               S02:0000052E:  42 40
F09:0096       	clr					d1
               S02:00000530:  42 41
F09:0097       	move.w				(a0)+,d0			; Read the file ID for the sprite tiles into d0
               S02:00000532:  30 18
F09:0098       	move.w				(a0)+,d1			; Read the file ID for the sprite definition into d1
               S02:00000534:  32 18
F09:0099       	jsr					rendLoadSprite(pc)	;
               S02:00000536:  4E BA 02 74
F09:0100       	push.w				d0
F11:0001       	move.l		d0,-(sp)
               S02:0000053A:  2F 00
F09:0101       
F09:0102       	; Fetch the address to the game object manager
F09:0103       	jsr					memGetGameObjectManagerBaseAddress(pc)
               S02:0000053C:  4E BA FF C0
F09:0104       	; Now a0 is the address to the game object manager
F09:0105       
F09:0106       	; Find the next free game object ID
F09:0107       	move.w				_gom_numobjects(a0),d0
               S02:00000540:  30 10
F09:0108       	clr.l				d3
               S02:00000542:  76 00
F09:0109       	move.w				d0,d3					; Retain the ID of the new object so we can return it properly
               S02:00000544:  36 00
F09:0110       
F09:0111       	; "Allocate" the object ID
F09:0112       	add.w				#1,_gom_numobjects(a0)
               S02:00000546:  52 50
F09:0113       
F09:0114       	; Now we have an object ID, wen can turn that into an address for our object data
F09:0115       	move				d0,d1
               S02:00000548:  32 00
F09:0116       	mulu				#_go_size,d1			; First we take the ID and turn into a byte offset from the game object manager base memory
               S02:0000054A:  C2 FC 00 0A
F09:0117       	add.l				#_gom_gameobjects,a0	; a0 is the gom base address, so offset that into the game objects array
               S02:0000054E:  50 88
F09:0118       	add.l				d1,a0					; From the game object array, go to the specific game object
               S02:00000550:  D1 C1
F09:0119       	; Current register status at this point
F09:0120       	; a0=the data for this specific game object
F09:0121       	; d0=the object ID for the game object we're working on
F09:0122       	; a1=unused
F09:0123       	; d1=unused
F09:0124       
F09:0125       	; Retain the sprite handle in this game object
F09:0126       	pop.w				d2
F12:0001       	move.l		(sp)+,d2
               S02:00000552:  24 1F
F09:0127       	move.w				d2,_go_sprite_handle(a0)
               S02:00000554:  31 42 00 04
F09:0128       
F09:0129       	; Setup default values for our new game object
F09:0130       	move.w				#0,_go_anim_time(a0)
               S02:00000558:  31 7C 00 00 00 06
F09:0131       	move.w				#0,_go_world_pos_x(a0)
               S02:0000055E:  30 BC 00 00
F09:0132       	move.w				#0,_go_world_pos_y(a0)
               S02:00000562:  31 7C 00 00 00 02
F09:0133       	move.w				#0,_go_sort(a0)
               S02:00000568:  31 7C 00 00 00 08
F09:0134       
F09:0135       	; We also need to add this object to the draw order array
F09:0136       
F09:0137       	; Fetch the address to the game object manager
F09:0138       	jsr					memGetGameObjectManagerBaseAddress(pc)
               S02:0000056E:  4E BA FF 8E
F09:0139       	clr.l				d0
               S02:00000572:  70 00
F09:0140       	move.w				_gom_numobjects(a0),d0
               S02:00000574:  30 10
F09:0141       	; a0=the address to the game object manager
F09:0142       	; d0=the number of game objects in the scene
F09:0143       
F09:0144       	; Find the byte address to the next entry in the draw order table
F09:0145       	add.l				#_gom_draworder,a0
               S02:00000576:  41 E8 01 98
F09:0146       	add.l				d3,a0
               S02:0000057A:  D1 C3
F09:0147       	; Now a0 is the address of the next entry in the draw order table
F09:0148       
F09:0149       	; Add the new game object last in the draw order table
F09:0150       	move.b				d3,(a0)
               S02:0000057C:  10 83
F09:0151       
F09:0152       	;
F09:0153       	move.w				d3,d0				; Put the new object ID in the return register
               S02:0000057E:  30 03
F09:0154       
F09:0155       	;
F09:0156       	popm.l				d2-d3
F13:0001       	movem.l		(sp)+,d2-d3
               S02:00000580:  4C DF 00 0C
F09:0157       
F09:0158       	rts
               S02:00000584:  4E 75
F09:0159       
F09:0160       
F09:0161       ;==============================================================================
F09:0162       ;
F09:0163       ; Input
F09:0164       ;	d0=Game object handle
F09:0165       ;	d1=World position X
F09:0166       ;	d2=World position Y
F09:0167       ;
F09:0168       ;==============================================================================
F09:0169       
F09:0170       gomSetPosition:
F09:0171       	jsr				memGetGameObjectManagerBaseAddress(pc)
               S02:00000586:  4E BA FF 76
F09:0172       	add.l			#_gom_gameobjects,a0
               S02:0000058A:  50 88
F09:0173       	mulu			#_go_size,d0
               S02:0000058C:  C0 FC 00 0A
F09:0174       	add.l			d0,a0
               S02:00000590:  D1 C0
F09:0175       	; a0 is now pointing to the game object instance
F09:0176       
F09:0177       	move.w			d1,_go_world_pos_x(a0)
               S02:00000592:  30 81
F09:0178       	move.w			d2,_go_world_pos_y(a0)
               S02:00000594:  31 42 00 02
F09:0179       
F09:0180       	rts
               S02:00000598:  4E 75
F09:0181       
F09:0182       
F09:0183       gomSetCameraPosition:
F09:0184       	jsr				memGetGameObjectManagerBaseAddress(pc)
               S02:0000059A:  4E BA FF 62
F09:0185       	move			d0,_gom_camera_x(a0)
               S02:0000059E:  31 40 00 04
F09:0186       	move			d1,_gom_camera_y(a0)
               S02:000005A2:  31 41 00 06
F09:0187       	rts
               S02:000005A6:  4E 75
F09:0188       
F09:0189       ;==============================================================================
F09:0190       ;
F09:0191       ; Transform all world positions to screen
F09:0192       ; positions and refresh all sprite positions
F09:0193       ;
F09:0194       ;==============================================================================
F09:0195       
F09:0196       gomRender:
F09:0197       	pushm			d2-d7/a2-a7
F14:0001       	movem.l		d2-d7/a2-a7,-(sp)
               S02:000005A8:  48 E7 3F 3F
F09:0198       
F09:0199       	; Iterate over all game objects
F09:0200       	; For each game object:
F09:0201       	;	Transform them from world space to screen space
F09:0202       	;	Push the new screen space position to the renderer
F09:0203       
F09:0204       	; Fetch the address to the game object manager
F09:0205       	jsr				memGetGameObjectManagerBaseAddress(pc)
               S02:000005AC:  4E BA FF 50
F09:0206       	move.l			a0,a2
               S02:000005B0:  24 48
F09:0207       	; Now a2 is the address to the game object manager
F09:0208       
F09:0209       	; Fetch the camera position
F09:0210       	move.w			_gom_camera_x(a2),d3
               S02:000005B2:  36 2A 00 04
F09:0211       	move.w			_gom_camera_y(a2),d4
               S02:000005B6:  38 2A 00 06
F09:0212       
F09:0213       	; Update the background position
F09:0214       	clr.l			d0
               S02:000005BA:  70 00
F09:0215       	clr.l			d1
               S02:000005BC:  72 00
F09:0216       	move.w			d3,d0
               S02:000005BE:  30 03
F09:0217       	move.w			d4,d1
               S02:000005C0:  32 04
F09:0218       	jsr				rendSetScrollXY(pc)			; d0=x position, d1=y position
               S02:000005C2:  4E BA 01 8E
F09:0219       
F09:0220       	; Fetch the number of game objects allocated.
F09:0221       	clr.l			d5
               S02:000005C6:  7A 00
F09:0222       	move.w			_gom_numobjects(a2),d5
               S02:000005C8:  3A 12
F09:0223       	sub.w			#1,d5		; dbra needs to subtract one otherwise we'll loop too many times
               S02:000005CA:  53 45
F09:0224       
F09:0225       	; Calculate the address of the last object in the list (i.e., the
F09:0226       	; object we will work on first, since the ID is going from max to 0)
F09:0227       
F09:0228       	; d2 is the game object ID
F09:0229       	move.l			a2,a3			; a2 is the game object manager base address
               S02:000005CC:  26 4A
F09:0230       	add.w			#_gom_gameobjects,a3
               S02:000005CE:  50 4B
F09:0231       	move.w			d5,d0
               S02:000005D0:  30 05
F09:0232       	mulu			#_go_size,d0
               S02:000005D2:  C0 FC 00 0A
F09:0233       	add.w			d0,a3
               S02:000005D6:  D6 C0
F09:0234       
F09:0235       	; d0 is trash
F09:0236       	; d1 is trash
F09:0237       	; d2 is trash
F09:0238       	; d3 is camera X
F09:0239       	; d4 is camera Y
F09:0240       	; d5 is the game object ID, which is also used as the loop counter
F09:0241       	; a2 is the game object manager base address
F09:0242       	; a3 is now the address to the last game object and will be used for as a pointer to the current game object we're work
F09:0243       
F09:0244       .loop:
F09:0245       	move		_go_sprite_handle(a3),d0	; d0 = sprite handle
               S02:000005D8:  30 2B 00 04
F09:0246       
F09:0247       	move		_go_world_pos_x(a3),d1		; d1 = game object world position X
               S02:000005DC:  32 13
F09:0248       	move		_go_world_pos_y(a3),d2		; d2 = game object world position Y
               S02:000005DE:  34 2B 00 02
F09:0249       	sub			d3,d1						; World to camera space on X
               S02:000005E2:  92 43
F09:0250       	sub			d4,d2						; World to camera space on Y
               S02:000005E4:  94 44
F09:0251       	jsr			rendSetSpritePosition(pc)	; Refresh hardware sprite position
               S02:000005E6:  4E BA 02 B6
F09:0252       
F09:0253       	; Go to next game object (i.e. the game object that is
F09:0254       	; before this in memory, since we're iterating down)
F09:0255       	sub				#_go_size,a3
               S02:000005EA:  47 EB FF F6
F09:0256       	dbra			d5,.loop
               S02:000005EE:  51 CD FF E8
F09:0257       
F09:0258       	popm			d2-d7/a2-a7
F15:0001       	movem.l		(sp)+,d2-d7/a2-a7
               S02:000005F2:  4C DF FC FC
F09:0259       
F09:0260       	rts
               S02:000005F6:  4E 75
F09:0261       
F09:0262       ;
F09:0263       ; A simple bubble sort
F09:0264       ;
F09:0265       gomSortObjects:
F09:0266       	pushm			d2-d7/a2-a7
F16:0001       	movem.l		d2-d7/a2-a7,-(sp)
               S02:000005F8:  48 E7 3F 3F
F09:0267       
F09:0268       	; Fetch the address of the draw order table
F09:0269       	jsr				memGetGameObjectManagerBaseAddress(pc)
               S02:000005FC:  4E BA FF 00
F09:0270       	move.l			a0,a2
               S02:00000600:  24 48
F09:0271       	add.l			#_gom_draworder,a2
               S02:00000602:  45 EA 01 98
F09:0272       	move.l			a0,a3
               S02:00000606:  26 48
F09:0273       	add.l			#_gom_gameobjects,a3
               S02:00000608:  50 8B
F09:0274       
F09:0275       	; 
F09:0276       	move.w			_gom_numobjects(a0),d0
               S02:0000060A:  30 10
F09:0277       	sub.w			#1,d0						; Don't check the last object in the array since we always compare pairs (we compare i and i+1)
               S02:0000060C:  53 40
F09:0278       	sub.w			#1,d0						; Compensate for dbra
               S02:0000060E:  53 40
F09:0279       
F09:0280       	; a2=address to the draw order table
F09:0281       	; a3=address to the game object table
F09:0282       	; d0=num game objects in scene-1 (because bubble sort compair pairs)
F09:0283       .sort_again_loop:
F09:0284       	clr				d2
               S02:00000610:  42 42
F09:0285       	move.w			d0,d2			; d0 is the game object index for the sort loop
               S02:00000612:  34 00
F09:0286       	move.w			d0,d3
               S02:00000614:  36 00
F09:0287       	add.w			#1,d3			; d3 is the "other" index to the draw order table (index to game object B)
               S02:00000616:  52 43
F09:0288       	clr				d1				; d1 is flag that determine if we should do another round
               S02:00000618:  42 41
F09:0289       
F09:0290       .compare_loop:
F09:0291       	clr				d4
               S02:0000061A:  42 44
F09:0292       	clr				d5
               S02:0000061C:  42 45
F09:0293       	move.b			(a2,d2),d4		; d4 is index to game object A
               S02:0000061E:  18 32 20 00
F09:0294       	move.b			(a2,d3),d5		; d5 is index to game object B
               S02:00000622:  1A 32 30 00
F09:0295       	mulu			#_go_size,d4	; d4 is now byte offset from game object table start to game object A
               S02:00000626:  C8 FC 00 0A
F09:0296       	mulu			#_go_size,d5	; d5 is now byte offset from game object table start to game object B
               S02:0000062A:  CA FC 00 0A
F09:0297       	move.l			a3,a4
               S02:0000062E:  28 4B
F09:0298       	move.l			a3,a5
               S02:00000630:  2A 4B
F09:0299       	add.l			d4,a4						; a4 is now the address to game object A
               S02:00000632:  D9 C4
F09:0300       	add.l			d5,a5						; a5 is now the address to game object B
               S02:00000634:  DB C5
F09:0301       	move.w			_go_world_pos_y(a4),d4		; d4 is now the sort value for game object A
               S02:00000636:  38 2C 00 02
F09:0302       	move.w			_go_world_pos_y(a5),d5		; d5 is now the sort value for game object B
               S02:0000063A:  3A 2D 00 02
F09:0303       
F09:0304       	cmp				d4,d5
               S02:0000063E:  BA 44
F09:0305       	bge.w			.no_swap
               S02:00000640:  6C 00 00 16
F09:0306       
F09:0307       	;
F09:0308       	; d4 is greater than d5, so we need to swap the objects
F09:0309       	;
F09:0310       	or.w			#1,d1			; Set the "loop again" flag
               S02:00000644:  82 7C 00 01
F09:0311       
F09:0312       	;
F09:0313       	; Swap indices
F09:0314       	;
F09:0315       	move.b			(a2,d2),d4		; d4 is index to game object A
               S02:00000648:  18 32 20 00
F09:0316       	move.b			(a2,d3),d5		; d5 is index to game object B
               S02:0000064C:  1A 32 30 00
F09:0317       	move.b			d5,(a2,d2)
               S02:00000650:  15 85 20 00
F09:0318       	move.b			d4,(a2,d3)
               S02:00000654:  15 84 30 00
F09:0319       
F09:0320       .no_swap:
F09:0321       	sub.w			#1,d3
               S02:00000658:  53 43
F09:0322       	dbra			d2,.compare_loop
               S02:0000065A:  51 CA FF BE
F09:0323       
F09:0324       	; Did we do any changes this iteration, so we need to check again?
F09:0325       	cmp.w			#0,d1
               S02:0000065E:  4A 41
F09:0326       	bne				.sort_again_loop
               S02:00000660:  66 AE
F09:0327       
F09:0328       	;
F09:0329       	; Fill the renderer draw table with sprite handles, in the correct order
F09:0330       	;
F09:0331       	move.l			a0,a4
               S02:00000662:  28 48
F09:0332       	add.l			#_gom_draworder_sprites,a4
               S02:00000664:  49 EC 01 C1
F09:0333       	move.l			a4,a1
               S02:00000668:  22 4C
F09:0334       	add.l			#_go_sprite_handle,a3
               S02:0000066A:  58 8B
F09:0335       	clr.l			d2
               S02:0000066C:  74 00
F09:0336       	move.w			_gom_numobjects(a0),d2
               S02:0000066E:  34 10
F09:0337       	sub.w			#1,d2						; compensate for dbra
               S02:00000670:  53 42
F09:0338       	; a0=game object manager base address
F09:0339       	; a1=draw order table, with sprite handles
F09:0340       	; a2=draw order table, with game object handles
F09:0341       	; a3=address to sprite handle of first game object
F09:0342       	; a4=draw order table, with sprite handles (will be incremented on each write)
F09:0343       	; d0=number of game objects in the game object manager
F09:0344       
F09:0345       	; Now we want to iterate over a2 and read that value, which is a game object handle, d0 times
F09:0346       	; We want to use that game object handle to get the sprite handle for that game object (a3 + (go index*go_size))
F09:0347       	; We want to write that sprite handle in the correct place in the draw order table of sprite handles (a4)
F09:0348       .gom_to_sprite_loop:
F09:0349       	clr.l			d1
               S02:00000672:  72 00
F09:0350       	move.b			(a2)+,d1					; d1 is now game object handle
               S02:00000674:  12 1A
F09:0351       	mulu			#_go_size,d1				; d1 is now byte offset to game object data from game object base address
               S02:00000676:  C2 FC 00 0A
F09:0352       	move.w			(a3,d1),d1					; d1 is now the sprite handle for this game object
               S02:0000067A:  32 33 10 00
F09:0353       	move.b			d1,(a4)+
               S02:0000067E:  18 C1
F09:0354       	dbra			d2,.gom_to_sprite_loop
               S02:00000680:  51 CA FF F0
F09:0355       
F09:0356       	; At this point everything is sorted. Let the renderer know.
F09:0357       	clr.l			d0
               S02:00000684:  70 00
F09:0358       	move.w			_gom_numobjects(a0),d0
               S02:00000686:  30 10
F09:0359       	sub.w			#1,d0						; compensate for dbra
               S02:00000688:  53 40
F09:0360       	move.l			a1,a0							; Address to draw order table should be in a0
               S02:0000068A:  20 49
F09:0361       	jsr				rendSetSpriteDrawOrder(pc)
               S02:0000068C:  4E BA 01 BE
F09:0362       
F09:0363       	; Done and done
F09:0364       	popm			d2-d7/a2-a7
F17:0001       	movem.l		(sp)+,d2-d7/a2-a7
               S02:00000690:  4C DF FC FC
F09:0365       	rts
               S02:00000694:  4E 75
F09:0366       
F00:0011       	include		"../src/platform/megadrive/mem.asm"
F18:0001       platform_mem_size				= $2000
F18:0002       platform_mem_start				= $00ff0000+totalmem_size
F18:0003       
F18:0004       platform_renderer_start			= platform_mem_start
F18:0005       platform_renderer_size			= $500
F18:0006       
F18:0007       
F18:0008       ;==================================================================================================
F18:0009       ;
F18:0010       ; Get the base address for this platform
F18:0011       ;
F18:0012       ;==================================================================================================
F18:0013       memGetPlatformBase:
F18:0014       	move.l			#$00ff0000,a0
               S02:00000696:  20 7C 00 FF 00 00
F18:0015       	rts
               S02:0000069C:  4E 75
F18:0016       
F00:0012       	include		"../src/platform/megadrive/inp.asm"
F19:0001       ;==============================================================================
F19:0002       ;
F19:0003       ; It is quite likely that the bit positions for the different buttons will be
F19:0004       ; different on the different platforms so the macros for them should be in the
F19:0005       ; platform specific source file.
F19:0006       ;
F19:0007       ;==============================================================================
F19:0008       INPUT_UP			equ		0
F19:0009       INPUT_DOWN			equ		1
F19:0010       INPUT_LEFT			equ		2
F19:0011       INPUT_RIGHT			equ		3
F19:0012       INPUT_ACTION		equ		6
F19:0013       INPUT_PAUSE			equ		7
F19:0014       INPUT_ACTION2		equ		4
F19:0015       INPUT_ACTION3		equ		5
F19:0016       
F19:0017       
F19:0018       ;
F19:0019       ; Some kind if input init, by M3
F19:0020       ;
F19:0021       inpInit:
F19:0022       	moveq	#$40,d0
               S02:0000069E:  70 40
F19:0023       	; Init code from sgdk, converted to assembler by me.
F19:0024       
F19:0025       	lea			$a10009,a0
               S02:000006A0:  41 F9 00 A1 00 09
F19:0026       	move.b		d0,(a0)
               S02:000006A6:  10 80
F19:0027       	addq.w		#2,a0
               S02:000006A8:  54 48
F19:0028       	move.b		d0,(a0)
               S02:000006AA:  10 80
F19:0029       	addq.w		#2,a0
               S02:000006AC:  54 48
F19:0030       	move.b		d0,(a0)
               S02:000006AE:  10 80
F19:0031       
F19:0032       	lea			$a10003,a0
               S02:000006B0:  41 F9 00 A1 00 03
F19:0033       	move.b		d0,(a0)
               S02:000006B6:  10 80
F19:0034       	addq.w		#2,a0
               S02:000006B8:  54 48
F19:0035       	move.b		d0,(a0)
               S02:000006BA:  10 80
F19:0036       	addq.w		#2,a0
               S02:000006BC:  54 48
F19:0037       	move.b		d0,(a0)
               S02:000006BE:  10 80
F19:0038       
F19:0039       	rts
               S02:000006C0:  4E 75
F19:0040       
F19:0041       
F19:0042       ;==============================================================================
F19:0043       ; Read joypad 1
F19:0044       ;
F19:0045       ; Returns the joypad values in the last byte of D7 with the following layout:
F19:0046       ; SACBRLDU (Start A C B Right Left Down Up)
F19:0047       ;==============================================================================
F19:0048       inpUpdate:
F19:0049       	;
F19:0050       	move.l		#$00A10003,a0				; Joypad 1 is at 0x00A10003
               S02:000006C2:  20 7C 00 A1 00 03
F19:0051       
F19:0052       	;
F19:0053       	move.b		#$40,(a0)					; Set TH to high
               S02:000006C8:  10 BC 00 40
F19:0054       	nop										; Wait for the bus to synchronize
               S02:000006CC:  4E 71
F19:0055       	move.b		(a0),d0						; Read status into D7
               S02:000006CE:  10 10
F19:0056       
F19:0057       	andi.b		#$3F,d0						; d0.b = 00CBRLDU
               S02:000006D0:  02 00 00 3F
F19:0058       
F19:0059       	move.b		#$00,(a0)					; Set TH to low
               S02:000006D4:  10 BC 00 00
F19:0060       	nop										; Wait for the bus to synchronize
               S02:000006D8:  4E 71
F19:0061       	move.b		(a0),d1						; Read status into d1
               S02:000006DA:  12 10
F19:0062       											; d1.b = ?0SA00DU
F19:0063       
F19:0064       	rol			#2,d1						; d1.b = SA00DU??
               S02:000006DC:  E5 59
F19:0065       	andi.b		#$C0,d1						; d1.b = SA000000
               S02:000006DE:  02 01 00 C0
F19:0066       	or.b 		d1,d0						; d0.b = SACBRLDU
               S02:000006E2:  80 01
F19:0067       
F19:0068       	rts										; Return to caller
               S02:000006E4:  4E 75
F19:0069       
F00:0013       	include		"../src/platform/megadrive/rend.asm"
F20:0001       ;==============================================================================
F20:0002       ;
F20:0003       ; Structures
F20:0004       ;
F20:0005       ;==============================================================================
F20:0006       ;
F20:0007       ; Renderer sprite information
F20:0008       ;
F20:0009       ;	rsreset
F20:0010       ;sRendSprite_TileID:			rs.l	1
F20:0011       ;sRendSprite_FileID:			rs.w	1
F20:0012       ;sRendSprite_Size:			rs.b	1
F20:0013       
F20:0014       ;
F20:0015       ; Constants
F20:0016       ;
F20:0017       rend_num_sprites		= 80
F20:0018       hw_sprite_byte_size		= 8
F20:0019       
F20:0020       ;
F20:0021       ;
F20:0022       ;
F20:0023       	rsreset
F20:0024       _cpu_sprite_mirror		rs.b		8
F20:0025       _cpu_sprite_fileid_tiles	rs.w		1			; The file ID for the loaded 
F20:0026       _cpu_sprite_fileid_sprite	rs.w		1			; The file ID for the sprite definition
F20:0027       _cpu_sprite_tileid		rs.w		1
F20:0028       _cpu_sprite_size		rs.l		0
F20:0029       
F20:0030       ;
F20:0031       ; CPU Memory map
F20:0032       ;
F20:0033       	setso				platform_renderer_start
F20:0034       VarVsync				so.l 	1										; Vertical sync counter
F20:0035       VarHsync				so.l	1										; Horizontal sync counter
F20:0036       VarNextSpriteAddress	so.l	1										; The address where the last loaded sprite tiles was loaded to
F20:0037       VarLockedSpriteAddress	so.l	1										; Locked address where we can free tiles to
F20:0038       VarNextSpriteSlot		so.l	1										; Next available sprite index in our sprite tables
F20:0039       VarLockedSpriteSlot		so.l	1										; Locked sprite index for free
F20:0040       VarLoadedPalette		so.w	1										; The file ID of the last loaded palette
F20:0041       VarLoadedTileBank		so.w	1										; The file ID of the last loaded tile bank
F20:0042       VarLoadedTileMap		so.w	1										; The file ID of the last loaded tile map
F20:0043       VarHWSprites			so.b	_cpu_sprite_size*rend_num_sprites		; This is reserved to the cpu ram mirror of the VRAM
F20:0044       	clrso
F20:0045       
F20:0046       ;
F20:0047       ; VRAM memory map
F20:0048       ;
F20:0049       VRAM_MapTiles_Start				= $0000
F20:0050       VRAM_SpriteTiles_Start			= $b800		; This one goes down when allocated, so it should be the same as another VRAM tag
F20:0051       VRAM_SpriteAttributes_Start		= $b800		; There are requirements as to what this address can be! (Only the top 6 bits are 
F20:0052       VRAM_HScroll_Start				= $bc00		; There are requirements as to what this address can be! (Only the top 6 bits are used.)
F20:0053       VRAM_TileMap0_Start				= $c000
F20:0054       VRAM_TileMap1_Start				= $e000
F20:0055       
F20:0056       
F20:0057       ;
F20:0058       ; Convert a regular integer value into a VRAM address
F20:0059       ; and move that converted address into a register
F20:0060       ;
F20:0061       ; Usage:
F20:0062       ; move_vram_addr	$a000,d0		; Convert $a000 to $60000002 (or whatever it becomes) and move that into d0
F20:0063       ;
F20:0064       move_vram_addr	MACRO
F20:0066       
F20:0067       
F20:0068       
F20:0069       ;==============================================================================
F20:0070       ;
F20:0071       ; Initialize the VDP and CPU states of the renderer
F20:0072       ;
F20:0073       ;==============================================================================
F20:0074       rendInit:
F20:0075       	move.l		#1,(VarNextSpriteSlot)
               S02:000006E6:  23 FC 00 00 00 01 00 FF E0 10
F20:0076       	move.l		#1,(VarLockedSpriteSlot)
               S02:000006F0:  23 FC 00 00 00 01 00 FF E0 14
F20:0077       	move.l		#VRAM_SpriteTiles_Start,(VarNextSpriteAddress)
               S02:000006FA:  23 FC 00 00 B8 00 00 FF E0 08
F20:0078       	move.l		#VRAM_SpriteTiles_Start,(VarLockedSpriteAddress)
               S02:00000704:  23 FC 00 00 B8 00 00 FF E0 0C
F20:0079       	move.w		#-1,(VarLoadedPalette)
               S02:0000070E:  33 FC FF FF 00 FF E0 18
F20:0080       	move.w		#-1,(VarLoadedTileBank)
               S02:00000716:  33 FC FF FF 00 FF E0 1A
F20:0081       	move.w		#-1,(VarLoadedTileMap)
               S02:0000071E:  33 FC FF FF 00 FF E0 1C
F20:0082       
F20:0083       	; Clear all mirror sprites
F20:0084       	move.l		#0,d0
               S02:00000726:  70 00
F20:0085       	move.l		#(_cpu_sprite_size*rend_num_sprites/4)-1,d1
               S02:00000728:  22 3C 00 00 01 17
F20:0086       	move.l		#VarHWSprites,a0
               S02:0000072E:  20 7C 00 FF E0 1E
F20:0087       
F20:0088       .clear_loop:
F20:0089       	move.l  	d0,(a0)+
               S02:00000734:  20 C0
F20:0090       	dbra    	d1,.clear_loop
               S02:00000736:  51 C9 FF FC
F20:0091       
F20:0092       	jsr			InitVDP
               S02:0000073A:  61 00 03 46
F20:0093       
F20:0094       
F20:0095       ;	move.l		#$00C00004,a0
F20:0096       ;	move.w		#$8F02,(a0)
F20:0097       ;	move_vram_addr	VRAM_HScroll_Start,(a0)
F20:0098       ;
F20:0099       ;	move.l		#$00C00000,a0
F20:0100       ;
F20:0101       ;	move		#240,d0			; Write 240 scan lines of data
F20:0102       ;	move		#0,d1
F20:0103       ;
F20:0104       ;.hscoll_loop:
F20:0105       ;	move.w		d1,(a0)			; Write to plane A hscroll table
F20:0106       ;	move.w		d1,(a0)			; Write to plane B hscroll table
F20:0107       ;	add			#1,d1
F20:0108       ;	and			#$1f,d1
F20:0109       ;	dbra		d0,.hscoll_loop
F20:0110       
F20:0111       	rts
               S02:0000073E:  4E 75
F20:0112       
F20:0113       
F20:0114       ;==============================================================================
F20:0115       ;
F20:0116       ; WaitVsync
F20:0117       ;
F20:0118       ;==============================================================================
F20:0119       rendWaitVSync:
F20:0120       	; Read initial value
F20:0121       	move.l		(VarVsync),d0			; Read value from VarVsync into D0
               S02:00000740:  20 39 00 FF E0 00
F20:0122       
F20:0123       .loop:
F20:0124       	; Read current value and see if it has changed
F20:0125       	move.l		(VarVsync),d1			; Read value from VarVsync into D1
               S02:00000746:  22 39 00 FF E0 00
F20:0126       	cmp.l		d0,d1					; Compare D0 and D1
               S02:0000074C:  B2 80
F20:0127       
F20:0128       	; No change means jump. Change means fall through.
F20:0129       	beq			.loop					; If result is 0 the value has not been changed
               S02:0000074E:  67 F6
F20:0130       										; so jump back to 1
F20:0131       
F20:0132       	rts									; Return to caller
               S02:00000750:  4E 75
F20:0133       
F20:0134       
F20:0135       ;==============================================================================
F20:0136       ;
F20:0137       ; Set scroll position for both horizontal scroll (X) and vertical scroll (Y)
F20:0138       ;
F20:0139       ; d0=X scroll
F20:0140       ; d1=Y scroll
F20:0141       ;
F20:0142       ;==============================================================================
F20:0143       rendSetScrollXY:
F20:0144       	and			#511,d0
               S02:00000752:  C0 7C 01 FF
F20:0145       	and			#511,d1
               S02:00000756:  C2 7C 01 FF
F20:0146       	muls		#-1,d0
               S02:0000075A:  C1 FC FF FF
F20:0147       	add			#512,d0
               S02:0000075E:  D0 7C 02 00
F20:0148       
F20:0149       	; Setup CPU registers and VDP auto increment register
F20:0150       	move.l		#$00C00000,a0		; Throughout all my code I'll use A4
               S02:00000762:  20 7C 00 C0 00 00
F20:0151       	move.l		#$00C00004,a1		; for the VDP data port and A5 for the
               S02:00000768:  22 7C 00 C0 00 04
F20:0152       	move.w		#$8F02,(a1)			; Disable autoincrement
               S02:0000076E:  32 BC 8F 02
F20:0153       
F20:0154       	; Set horizontal scroll
F20:0155       	move_vram_addr	VRAM_HScroll_Start,(a1)
F21:0001       	move.l		#((((VRAM_HScroll_Start)&$3fff)<<16)+(((VRAM_HScroll_Start)>>14)&3))|(1<<30),(a1)
               S02:00000772:  22 BC 7C 00 00 02
F20:0156       	move.w		d0,(a0)
               S02:00000778:  30 80
F20:0157       	move.w		d0,(a0)
               S02:0000077A:  30 80
F20:0158       
F20:0159       	; Set vertical scroll
F20:0160       	move.l		#$40000010,(a1)		; Point the VDP data port to the vertical scroll table
               S02:0000077C:  22 BC 40 00 00 10
F20:0161       	move.w		d1,(a0)
               S02:00000782:  30 81
F20:0162       	move.w		d1,(a0)
               S02:00000784:  30 81
F20:0163       
F20:0164       	rts
               S02:00000786:  4E 75
F20:0165       
F20:0166       
F20:0167       ;==============================================================================
F20:0168       ;
F20:0169       ; Load a tile bank into VRAM
F20:0170       ;
F20:0171       ; d0=file ID of tile bank file to load into VRAM
F20:0172       ;
F20:0173       ;==============================================================================
F20:0174       rendLoadTileBank:
F20:0175       	move.w		(VarLoadedTileBank),d1
               S02:00000788:  32 39 00 FF E0 1A
F20:0176       	cmp.w		d0,d1
               S02:0000078E:  B2 40
F20:0177       	beq			.done
               S02:00000790:  67 18
F20:0178       
F20:0179       	; Remember which tile bank has been loaded
F20:0180       	move.w		d0,(VarLoadedTileBank)
               S02:00000792:  33 C0 00 FF E0 1A
F20:0181       
F20:0182       	; fileLoad accept the file ID as d0, so no need to do any tricks here
F20:0183       	jsr			fileLoad
               S02:00000798:  61 00 03 30
F20:0184       	; a0 is the return address from fileLoad, so it is set to the source address now
F20:0185       
F20:0186       	; Create the number of longs to copy, based in the number of tiles from the file
F20:0187       	move.w		(a0)+,d1
               S02:0000079C:  32 18
F20:0188       	lsl			#5-2,d1		; We should shift up 5 bits because each tile is
               S02:0000079E:  E7 49
F20:0189       							; 32 bytes, but we should also shift down 2 bits
F20:0190       							; because we copy 4 bytes per copy
F20:0191       
F20:0192       	; Now create the VRAM offset
F20:0193       	move_vram_addr		VRAM_MapTiles_Start,d0
F22:0001       	move.l		#((((VRAM_MapTiles_Start)&$3fff)<<16)+(((VRAM_MapTiles_Start)>>14)&3))|(1<<30),d0
               S02:000007A0:  20 3C 40 00 00 00
F20:0194       
F20:0195       	; d0=destination offset
F20:0196       	; d1=size to copy
F20:0197       	; a0=source address
F20:0198       	jsr			_rendCopyToVRAM
               S02:000007A6:  61 00 02 0A
F20:0199       .done:
F20:0200       
F20:0201       	rts
               S02:000007AA:  4E 75
F20:0202       
F20:0203       
F20:0204       ;==============================================================================
F20:0205       ;
F20:0206       ; Loads a sprite into memory. Both allocates a sprite attribute slot and load
F20:0207       ; the sprite tiles into VRAM.
F20:0208       ;
F20:0209       ; Input
F20:0210       ;	d0=file ID of tile bank file to load into VRAM
F20:0211       ;	d1=file ID of the sprite file that configures
F20:0212       ;
F20:0213       ; Output
F20:0214       ;	d0=Sprite handle
F20:0215       ;
F20:0216       ;==============================================================================
F20:0217       rendLoadSprite:
F20:0218       	; Setup a stack frame and store some stuffs
F20:0219       	stack_alloc		16
F23:0001       	sub.l		#16,sp
               S02:000007AC:  4F EF FF F0
F20:0220       	stack_write.l	d3,0
F24:0001       	move.l		d3,0(sp)
               S02:000007B0:  2E 83
F20:0221       	stack_write.l	d1,4
F25:0001       	move.l		d1,4(sp)
               S02:000007B2:  2F 41 00 04
F20:0222       
F20:0223       	; fileLoad accept the file ID as d0, so no need to do any tricks here
F20:0224       	jsr				fileLoad
               S02:000007B6:  61 00 03 12
F20:0225       	; a0 is the return address from fileLoad
F20:0226       
F20:0227       	; Load the number of tiles to copy from the bank data
F20:0228       	move.w			(a0)+,d1
               S02:000007BA:  32 18
F20:0229       	lsl				#5,d1		; Now we have the byte size of the
               S02:000007BC:  EB 49
F20:0230       								; tiles that should be loaded
F20:0231       
F20:0232       	; Find VRAM address to load the tiles to
F20:0233       	move.l			(VarNextSpriteAddress),d0
               S02:000007BE:  20 39 00 FF E0 08
F20:0234       	sub.l			d1,d0
               S02:000007C4:  90 81
F20:0235       	move.l			d0,(VarNextSpriteAddress)
               S02:000007C6:  23 C0 00 FF E0 08
F20:0236       	; d0 is now the VRAM address to load the sprite tiles to
F20:0237       
F20:0238       	stack_write.l	d0,8
F26:0001       	move.l		d0,8(sp)
               S02:000007CC:  2F 40 00 08
F20:0239       	stack_write.l	d1,12
F27:0001       	move.l		d1,12(sp)
               S02:000007D0:  2F 41 00 0C
F20:0240       	jsr				_rendIntegerToVRAMAddress
               S02:000007D4:  61 00 02 8C
F20:0241       	stack_read.l	d1,12
F28:0001       	move.l		12(sp),d1
               S02:000007D8:  22 2F 00 0C
F20:0242       
F20:0243       	lsr				#2,d1		; d1 is the size of the tiles in bytes, but it
               S02:000007DC:  E4 49
F20:0244       								; should be the size in longs for _rendCopyToVRAM
F20:0245       
F20:0246       	; d0=destination offset
F20:0247       	; d1=size to copy
F20:0248       	; a0=source address
F20:0249       	jsr				_rendCopyToVRAM
               S02:000007DE:  61 00 01 D2
F20:0250       	stack_read.l	d0,8
F29:0001       	move.l		8(sp),d0
               S02:000007E2:  20 2F 00 08
F20:0251       
F20:0252       	; Fetch the next available sprite slot
F20:0253       	move.l			(VarNextSpriteSlot),d1
               S02:000007E6:  22 39 00 FF E0 10
F20:0254       	move.l			d1,d3
               S02:000007EC:  26 01
F20:0255       
F20:0256       	; And allocate one
F20:0257       	add.l			#1,(VarNextSpriteSlot)
               S02:000007EE:  52 B9 00 FF E0 10
F20:0258       
F20:0259       	; Find address of sprite attributes mirror and renderer sprite data
F20:0260       	mulu			#_cpu_sprite_size,d1
               S02:000007F4:  C2 FC 00 0E
F20:0261       	add.l			#VarHWSprites,d1
               S02:000007F8:  D2 BC 00 FF E0 1E
F20:0262       	move.l			d1,a0
               S02:000007FE:  20 41
F20:0263       	; Now a0 points to somewhere in the sprite attributes mirror table
F20:0264       
F20:0265       	; d0 still points to the VRAM address, in bytes, that the tiles
F20:0266       	; was copied to. Lets convert that into a tile ID and store in
F20:0267       	; the sprite hw mirror table.
F20:0268       	lsr				#5,d0
               S02:00000800:  EA 48
F20:0269       
F20:0270       	; d0=Tile ID of the sprite tile bank where the data was loaded to
F20:0271       	; a0=Address of the sprite hw attribute table mirror for the sprite that was allocated
F20:0272       	jsr				_rendSetSpriteTileID_Address
               S02:00000802:  61 00 01 CA
F20:0273       
F20:0274       	; We also want to retain the tile ID in the CPU sprite memory
F20:0275       	move.w			d0,_cpu_sprite_tileid(a0)
               S02:00000806:  31 40 00 0C
F20:0276       
F20:0277       	; Load the sprite information file to get the dimensions of the sprite
F20:0278       	; Read the file ID from the stack
F20:0279       	stack_read.l	d0,4
F30:0001       	move.l		4(sp),d0
               S02:0000080A:  20 2F 00 04
F20:0280       
F20:0281       	; Retain the address to the sprite mirror table for this sprite
F20:0282       	stack_write.l	a0,4
F31:0001       	move.l		a0,4(sp)
               S02:0000080E:  2F 48 00 04
F20:0283       
F20:0284       	; d0=File ID of the sprite information file
F20:0285       	jsr				fileLoad
               S02:00000812:  61 00 02 B6
F20:0286       	; d0 is now the size of the sprites file
F20:0287       	; a0 is the address to the sprite information
F20:0288       
F20:0289       	move.b			(a0)+,d0	; Fetch sprite width in pixels
               S02:00000816:  10 18
F20:0290       	move.b			(a0)+,d1	; Fetch sprite height in pixels
               S02:00000818:  12 18
F20:0291       	lsr				#3,d0		; Convert width from pixels to tiles
               S02:0000081A:  E6 48
F20:0292       	lsr				#3,d1		; Convert height from pixels to tiles
               S02:0000081C:  E6 49
F20:0293       
F20:0294       	; Also, on the Mega Drive, the width and size are defined from 0-3,
F20:0295       	; where 0 means 1 tile wide, and 3 means 4 tiles wide) So we need
F20:0296       	; to subtract one from the tile dimensions
F20:0297       	sub				#1,d0
               S02:0000081E:  53 40
F20:0298       	sub				#1,d1
               S02:00000820:  53 41
F20:0299       
F20:0300       	; Fetch the sprite mirror table address
F20:0301       	stack_read.l	a0,4
F32:0001       	move.l		4(sp),a0
               S02:00000822:  20 6F 00 04
F20:0302       
F20:0303       	; d0=Sprite width, in tiles
F20:0304       	; d1=Sprite height, in tiles
F20:0305       	; a0=Sprite mirror table address
F20:0306       	jsr				_rendSetSpriteDimensions_Address
               S02:00000826:  61 00 01 BA
F20:0307       
F20:0308       	; Set sprite coordinates
F20:0309       	move.l			#0,d0
               S02:0000082A:  70 00
F20:0310       	move.l			#0,d1
               S02:0000082C:  72 00
F20:0311       	jsr				_rendSetSpritePosition_Address
               S02:0000082E:  61 00 01 C6
F20:0312       
F20:0313       	move.l			d3,d0		; d3 is the sprite slot ID
               S02:00000832:  20 03
F20:0314       	jsr				_rendCopySpriteToVRAM_Index
               S02:00000834:  61 00 01 F6
F20:0315       
F20:0316       	; Sprite 0 is always rendered. But if this sprite isn't sprite 0 then
F20:0317       	; it needs to be added to the linked list of sprites to render
F20:0318       	cmp.l			#0,d3
               S02:00000838:  4A 83
F20:0319       	beq				.already_connected
               S02:0000083A:  67 06
F20:0320       
F20:0321       	move.l			d3,d0		; d3 is the sprite slot ID
               S02:0000083C:  20 03
F20:0322       	jsr				_rendAddSprite_Index
               S02:0000083E:  61 00 01 CA
F20:0323       
F20:0324       .already_connected:
F20:0325       
F20:0326       	; Put the sprite slot ID into d0 as the return value
F20:0327       	move.l			d3,d0
               S02:00000842:  20 03
F20:0328       
F20:0329       	; Clear up stack frame and be happy
F20:0330       	stack_read.l	d3,0
F33:0001       	move.l		0(sp),d3
               S02:00000844:  26 17
F20:0331       	stack_free		16
F34:0001       	add.l		#16,sp
               S02:00000846:  4F EF 00 10
F20:0332       	rts
               S02:0000084A:  4E 75
F20:0333       
F20:0334       
F20:0335       ;==============================================================================
F20:0336       ;
F20:0337       ; Set the draw order of our sprites. The table should contain sprite handles
F20:0338       ; in the order they should be drawn. That means that the sprite handle that
F20:0339       ; appear first in this table should be drawn first to the screen. The second
F20:0340       ; sprite that appears in the table should be dawn on top of the previous one.
F20:0341       ;
F20:0342       ; Input
F20:0343       ;	a0 = address to table of draw orders. Each entry should be 1 byte
F20:0344       ;	d0 = the number of entries in the table.
F20:0345       ;
F20:0346       ;==============================================================================
F20:0347       rendSetSpriteDrawOrder:
F20:0348       	pushm		d2-d7/a2-a7
F35:0001       	movem.l		d2-d7/a2-a7,-(sp)
               S02:0000084C:  48 E7 3F 3F
F20:0349       
F20:0350       	; a0 and d0 is expected to be trashed by subroutine calls
F20:0351       	move.l		a0,a2
               S02:00000850:  24 48
F20:0352       	clr.l		d2
               S02:00000852:  74 00
F20:0353       	move.b		d0,d2
               S02:00000854:  14 00
F20:0354       	add.l		d2,a2
               S02:00000856:  D5 C2
F20:0355       	add.l		#1,a2
               S02:00000858:  52 8A
F20:0356       
F20:0357       	; To compensate for the dbra that goes to -1 before quitting the loop
F20:0358       	;sub.b		#1,d2
F20:0359       
F20:0360       	; Find the address to the link attribute in the mirror table
F20:0361       	move.l		#VarHWSprites,d3
               S02:0000085A:  26 3C 00 FF E0 1E
F20:0362       	add.l		#_cpu_sprite_mirror,d3
               S02:00000860:  D6 BC 00 00 00 00
F20:0363       	add.l		#3,d3
               S02:00000866:  56 83
F20:0364       
F20:0365       	; First sprite to write link value into is always sprite #0
F20:0366       	clr			d4
               S02:00000868:  42 44
F20:0367       
F20:0368       	; Clear d0 so we can use .b operations on it
F20:0369       	clr			d0
               S02:0000086A:  42 40
F20:0370       
F20:0371       	move.l		#1,d6
               S02:0000086C:  7C 01
F20:0372       
F20:0373       	; a2=address to draw order table
F20:0374       	; d2=number of sprites
F20:0375       	; d3=address to link attribute in first sprite
F20:0376       	; d4=index of previous sprite (i.e. the sprite that we should write the current link value into)
F20:0377       .loop:
F20:0378       	move.l		d4,d0				; Retain the current sprite index in d0 because we need it for when we copy the CPU RAM to VRAM
               S02:0000086E:  20 04
F20:0379       	mulu		#_cpu_sprite_size,d4
               S02:00000870:  C8 FC 00 0E
F20:0380       	add.l		d3,d4
               S02:00000874:  D8 83
F20:0381       	move.l		d4,a3
               S02:00000876:  26 44
F20:0382       	; a3 is now the address to the link attribute for the "current" sprite
F20:0383       
F20:0384       	clr.l		d4
               S02:00000878:  78 00
F20:0385       	move.b		-(a2),d4			; d4 is now the index of the next sprite
               S02:0000087A:  18 22
F20:0386       	move.b		d4,(a3)				; Write the index of the next sprite in the current sprite link attribute
               S02:0000087C:  16 84
F20:0387       
F20:0388       	; d0 is already set up to be the index to the current sprits
F20:0389       	jsr			_rendCopySpriteToVRAM_Index
               S02:0000087E:  61 00 01 AC
F20:0390       
F20:0391       	dbra		d2,.loop
               S02:00000882:  51 CA FF EA
F20:0392       
F20:0393       	; At the last sprite we need to close the link list, by setting the link value to 0
F20:0394       	move.b		d4,d0				; Retain the current sprite index in d0 because we need it for when we copy the CPU RAM to VRAM
               S02:00000886:  10 04
F20:0395       	mulu		#_cpu_sprite_size,d4
               S02:00000888:  C8 FC 00 0E
F20:0396       	add.l		d3,d4
               S02:0000088C:  D8 83
F20:0397       	move.l		d4,a3
               S02:0000088E:  26 44
F20:0398       	; a3 is now the address to the link attribute for the "current" sprite
F20:0399       	move.b		#0,(a3)
               S02:00000890:  16 BC 00 00
F20:0400       	jsr			_rendCopySpriteToVRAM_Index
               S02:00000894:  61 00 01 96
F20:0401       
F20:0402       	popm		d2-d7/a2-a7
F36:0001       	movem.l		(sp)+,d2-d7/a2-a7
               S02:00000898:  4C DF FC FC
F20:0403       	rts
               S02:0000089C:  4E 75
F20:0404       
F20:0405       
F20:0406       ;==============================================================================
F20:0407       ;
F20:0408       ; Set the screen coordinate of a sprite given its ID
F20:0409       ;
F20:0410       ; Input
F20:0411       ;	d0 = Sprite ID
F20:0412       ;	d1 = X position. 0 is leftmost pixel on screen, negative allowed
F20:0413       ;	d2 = Y position. 0 is topmost pixel on screen, negative allowed
F20:0414       ;
F20:0415       ;==============================================================================
F20:0416       rendSetSpritePosition:
F20:0417       	push		d3
F37:0001       	move.l		d3,-(sp)
               S02:0000089E:  2F 03
F20:0418       	push		d1						; Push X coordinate to stack
F38:0001       	move.l		d1,-(sp)
               S02:000008A0:  2F 01
F20:0419       
F20:0420       	move.l		d0,d3					; Retain the sprite slot index in d3
               S02:000008A2:  26 00
F20:0421       	mulu		#_cpu_sprite_size,d0	; Calculate the byte offset to the sprite data
               S02:000008A4:  C0 FC 00 0E
F20:0422       
F20:0423       	;
F20:0424       	move.l		#VarHWSprites,d1		; Get base address to the sprite mirror table
               S02:000008A8:  22 3C 00 FF E0 1E
F20:0425       	add			d0,d1					; Add the offset to the sprite index before d0
               S02:000008AE:  D2 40
F20:0426       	move.l		d1,a0					; We want to address it
               S02:000008B0:  20 41
F20:0427       
F20:0428       	; a0 is now the address to the sprite slot in the sprite mirror table
F20:0429       	; d0 is garbage
F20:0430       	; d1 is garbage
F20:0431       	; d2 is the Y position
F20:0432       	pop			d0						; Pop X coordinate from stack
F39:0001       	move.l		(sp)+,d0
               S02:000008B2:  20 1F
F20:0433       	move.l		d2,d1
               S02:000008B4:  22 02
F20:0434       	jsr			_rendSetSpritePosition_Address
               S02:000008B6:  61 00 01 3E
F20:0435       
F20:0436       	; Refresh data in VRAM
F20:0437       	move.l		d3,d0
               S02:000008BA:  20 03
F20:0438       	jsr			_rendCopySpriteToVRAM_Index
               S02:000008BC:  61 00 01 6E
F20:0439       
F20:0440       	pop			d3
F40:0001       	move.l		(sp)+,d3
               S02:000008C0:  26 1F
F20:0441       	rts
               S02:000008C2:  4E 75
F20:0442       
F20:0443       
F20:0444       ;==============================================================================
F20:0445       ;
F20:0446       ; Set which frame of a sprite animation that should be shown
F20:0447       ;
F20:0448       ; d0=Sprite ID
F20:0449       ; d1=Frame index
F20:0450       ;
F20:0451       ;==============================================================================
F20:0452       rendSetSpriteFrame:
F20:0453       	push		d2
F41:0001       	move.l		d2,-(sp)
               S02:000008C4:  2F 02
F20:0454       
F20:0455       	push		d0							; Retain the sprite ID on the stack, for later
F42:0001       	move.l		d0,-(sp)
               S02:000008C6:  2F 00
F20:0456       
F20:0457       	mulu		#_cpu_sprite_size,d0		; Calculate the byte offset to the sprite data
               S02:000008C8:  C0 FC 00 0E
F20:0458       	move.l		#VarHWSprites,d2			; Get base address to the sprite mirror table
               S02:000008CC:  24 3C 00 FF E0 1E
F20:0459       	add			d0,d2						; Add the offset to the sprite index before d0
               S02:000008D2:  D4 40
F20:0460       	move.l		d2,a0						; We want to address it
               S02:000008D4:  20 42
F20:0461       	; now a0 point to the address of this sprites mirror
F20:0462       
F20:0463       	; d1 is the frame index. Convert that into tile
F20:0464       	; index offset from where it was loaded.
F20:0465       	mulu		#4,d1						; #4 needs to be read from somewhere, so we know how many tiles an individual frame is
               S02:000008D6:  C2 FC 00 04
F20:0466       
F20:0467       	add.w		_cpu_sprite_tileid(a0),d1	; Apply the original offset from when the sprite was loaded
               S02:000008DA:  D2 68 00 0C
F20:0468       
F20:0469       	move.w		4(a0),d0					; Read from the sprite mirror into d0
               S02:000008DE:  30 28 00 04
F20:0470       	and.w		#$f800,d0					; Remove the previous tile settings
               S02:000008E2:  C0 7C F8 00
F20:0471       	or.w		d1,d0						; Apply the new tile ID
               S02:000008E6:  80 41
F20:0472       	move.w		d0,4(a0)					; Update the CPU mirror
               S02:000008E8:  31 40 00 04
F20:0473       
F20:0474       	pop			d0							; Pop the sprite ID from the stack
F43:0001       	move.l		(sp)+,d0
               S02:000008EC:  20 1F
F20:0475       	jsr			_rendCopySpriteToVRAM_Index	;
               S02:000008EE:  61 00 01 3C
F20:0476       
F20:0477       	pop			d2
F44:0001       	move.l		(sp)+,d2
               S02:000008F2:  24 1F
F20:0478       
F20:0479       	rts
               S02:000008F4:  4E 75
F20:0480       
F20:0481       
F20:0482       ;==============================================================================
F20:0483       ;
F20:0484       ; Load a tile map into VRAM
F20:0485       ;
F20:0486       ; d0=file ID of tile bank file to load into VRAM
F20:0487       ; d1=Which slot to store the map in.
F20:0488       ;		Slot #0 - Background layer (behind sprites)
F20:0489       ;		Slot #1 - Foreground layer (in front of sprites)
F20:0490       ;
F20:0491       ;==============================================================================
F20:0492       rendLoadTileMap:
F20:0493       	;
F20:0494       	push		d2
F45:0001       	move.l		d2,-(sp)
               S02:000008F6:  2F 02
F20:0495       	move.w		(VarLoadedTileMap),d2
               S02:000008F8:  34 39 00 FF E0 1C
F20:0496       	cmp.w		d0,d2
               S02:000008FE:  B4 40
F20:0497       	beq			.done
               S02:00000900:  67 68
F20:0498       
F20:0499       	; Remember which tile map has been loaded
F20:0500       	move.w		d0,(VarLoadedTileMap)
               S02:00000902:  33 C0 00 FF E0 1C
F20:0501       
F20:0502       	push		d3
F46:0001       	move.l		d3,-(sp)
               S02:00000908:  2F 03
F20:0503       
F20:0504       	; Push the slot ID onto the stack
F20:0505       	push		d1
F47:0001       	move.l		d1,-(sp)
               S02:0000090A:  2F 01
F20:0506       
F20:0507       	; fileLoad accept the file ID as d0, so no need to do any tricks here
F20:0508       	jsr			fileLoad
               S02:0000090C:  61 00 01 BC
F20:0509       	; a0 is the return address from fileLoad, so it is set to the source address now
F20:0510       
F20:0511       	; Read the width and height of the tile map and calculate how many
F20:0512       	; longs to copy to get the entire tile map from file to VRAM
F20:0513       	move.b		(a0)+,d0
               S02:00000910:  10 18
F20:0514       	move.b		(a0)+,d1
               S02:00000912:  12 18
F20:0515       
F20:0516       	; Retain width and height in register d2 and d3
F20:0517       	clr			d2
               S02:00000914:  42 42
F20:0518       	clr			d3
               S02:00000916:  42 43
F20:0519       	move.b		d0,d2
               S02:00000918:  14 00
F20:0520       	move.b		d1,d3
               S02:0000091A:  16 01
F20:0521       
F20:0522       	mulu		d0,d1
               S02:0000091C:  C2 C0
F20:0523       	lsr			#1,d1
               S02:0000091E:  E2 49
F20:0524       
F20:0525       	; Now fetch the slot argument and convert to a VRAM destination address
F20:0526       	pop			d0
F48:0001       	move.l		(sp)+,d0
               S02:00000920:  20 1F
F20:0527       	lsl			#2,d0		; Multiply by 4 because we read longs from a1
               S02:00000922:  E5 48
F20:0528       	lea			.SlotAddresses,a1
               S02:00000924:  43 FA 00 48
F20:0529       	add.l		d0,a1
               S02:00000928:  D3 C0
F20:0530       	move.l		(a1),d0
               S02:0000092A:  20 11
F20:0531       
F20:0532       	; d0=destination offset
F20:0533       	; d1=size to copy
F20:0534       	; a0=source address
F20:0535       	jsr			_rendCopyToVRAM
               S02:0000092C:  61 00 00 84
F20:0536       
F20:0537       	; Set hardware register to match the loaded width and height
F20:0538       	move.w		#$9000,d0
               S02:00000930:  30 3C 90 00
F20:0539       
F20:0540       	; Check width
F20:0541       	cmp.b		#64,d2
               S02:00000934:  B4 3C 00 40
F20:0542       	beq			.width_64
               S02:00000938:  67 08
F20:0543       
F20:0544       	cmp.b		#128,d2
               S02:0000093A:  B4 3C 00 80
F20:0545       	beq			.width_128
               S02:0000093E:  67 08
F20:0546       
F20:0547       	bra			.check_height
               S02:00000940:  60 0A
F20:0548       
F20:0549       .width_64:
F20:0550       	or.w		#$0001,d0
               S02:00000942:  80 7C 00 01
F20:0551       	bra			.check_height
               S02:00000946:  60 04
F20:0552       
F20:0553       .width_128:
F20:0554       	or.w		#$0001,d0
               S02:00000948:  80 7C 00 01
F20:0555       
F20:0556       	; Check height of map
F20:0557       .check_height:
F20:0558       
F20:0559       	cmp.b		#64,d3
               S02:0000094C:  B6 3C 00 40
F20:0560       	beq			.height_64
               S02:00000950:  67 06
F20:0561       
F20:0562       	cmp.b		#128,d3
               S02:00000952:  B6 3C 00 80
F20:0563       	beq			.height_128
               S02:00000956:  67 06
F20:0564       
F20:0565       .height_64:
F20:0566       	or.w		#$0010,d0
               S02:00000958:  80 7C 00 10
F20:0567       	bra			.set_dimensions
               S02:0000095C:  60 04
F20:0568       
F20:0569       .height_128:
F20:0570       	or.w		#$0010,d0
               S02:0000095E:  80 7C 00 10
F20:0571       
F20:0572       .set_dimensions:
F20:0573       	move.w		d0,($00C00004)
               S02:00000962:  33 C0 00 C0 00 04
F20:0574       
F20:0575       	pop			d3
F49:0001       	move.l		(sp)+,d3
               S02:00000968:  26 1F
F20:0576       
F20:0577       .done:
F20:0578       	pop			d2
F50:0001       	move.l		(sp)+,d2
               S02:0000096A:  24 1F
F20:0579       
F20:0580       	rts
               S02:0000096C:  4E 75
F20:0581       
F20:0582       .SlotAddresses:
F20:0583       	dc.l		$40000003
               S02:0000096E:  40 00 00 03
F20:0584       	dc.l		$60000003	; Untested destination address
               S02:00000972:  60 00 00 03
F20:0585       
F20:0586       
F20:0587       ;==============================================================================
F20:0588       ;
F20:0589       ; Load a palette map into CRAM
F20:0590       ;
F20:0591       ; d0=file ID of palette file to load into CRAM
F20:0592       ; d1=Which slot index to store the palette in
F20:0593       ;	Allowed slot indices are 0 to 3 inclusive
F20:0594       ;
F20:0595       ;==============================================================================
F20:0596       rendLoadPalette:
F20:0597       	; Check if the requested palette is the one that we've already
F20:0598       	; loaded. In that case we can just ignore the request, because
F20:0599       	; this palette is already loaded.
F20:0600       	push		d2
F51:0001       	move.l		d2,-(sp)
               S02:00000976:  2F 02
F20:0601       	move.w		(VarLoadedPalette),d2
               S02:00000978:  34 39 00 FF E0 18
F20:0602       	cmp.w		d0,d2
               S02:0000097E:  B4 40
F20:0603       	beq			.done
               S02:00000980:  67 1C
F20:0604       
F20:0605       	; Remember that this palette file have been loaded
F20:0606       	move.w		d0,(VarLoadedPalette)
               S02:00000982:  33 C0 00 FF E0 18
F20:0607       
F20:0608       	; Push the slot index onto the stack
F20:0609       	move.l		d1,-(sp)
               S02:00000988:  2F 01
F20:0610       
F20:0611       	; fileLoad accept the file ID as d0, so no need to do any tricks here
F20:0612       	jsr			fileLoad
               S02:0000098A:  61 00 01 3E
F20:0613       	; a0 is the return address from fileLoad, so it is set to the source address now
F20:0614       
F20:0615       	; How many longs to copy
F20:0616       	move.l		#32/4,d1
               S02:0000098E:  72 08
F20:0617       
F20:0618       	; Now fetch the slot argument and convert to a CRAM destination address
F20:0619       	move.l		(sp)+,d0
               S02:00000990:  20 1F
F20:0620       	lsl			#2,d0		; Multiply by 4 because we read longs from a1
               S02:00000992:  E5 48
F20:0621       	lea			.SlotAddresses,a1
               S02:00000994:  43 FA 00 0C
F20:0622       	add.l		d0,a1
               S02:00000998:  D3 C0
F20:0623       	move.l		(a1),d0
               S02:0000099A:  20 11
F20:0624       
F20:0625       	; d0=destination offset
F20:0626       	; d1=size to copy
F20:0627       	; a0=source address
F20:0628       	jsr			_rendCopyToVRAM
               S02:0000099C:  61 14
F20:0629       
F20:0630       .done:
F20:0631       	pop			d2
F52:0001       	move.l		(sp)+,d2
               S02:0000099E:  24 1F
F20:0632       	rts
               S02:000009A0:  4E 75
F20:0633       
F20:0634       .SlotAddresses:
F20:0635       	dc.l		$C0000000	; Slot index 0
               S02:000009A2:  C0 00 00 00
F20:0636       	dc.l		$C0200000	; Slot index 1 - untested
               S02:000009A6:  C0 20 00 00
F20:0637       	dc.l		$C0400000	; Slot index 2 - untested
               S02:000009AA:  C0 40 00 00
F20:0638       	dc.l		$C0600000	; Slot index 3 - untested
               S02:000009AE:  C0 60 00 00
F20:0639       
F20:0640       
F20:0641       ;==============================================================================
F20:0642       ;
F20:0643       ; General copy from CPU to VRAM subroutine
F20:0644       ;
F20:0645       ; a0=source addres
F20:0646       ; d0=destination offset
F20:0647       ; d1=size to copy
F20:0648       ;
F20:0649       ;==============================================================================
F20:0650       _rendCopyToVRAM:
F20:0651       	move.l		#$00C00004,a1
               S02:000009B2:  22 7C 00 C0 00 04
F20:0652       
F20:0653           move.w  	#$8F02,(a1)				; Set autoincrement (register 15) to 2
               S02:000009B8:  32 BC 8F 02
F20:0654           move.l  	d0,(a1)					; Point data port to start of VRAM
               S02:000009BC:  22 80
F20:0655       
F20:0656       	move.l		#$00C00000,a1
               S02:000009BE:  22 7C 00 C0 00 00
F20:0657       
F20:0658       	sub.l		#1,d1
               S02:000009C4:  53 81
F20:0659       
F20:0660       .1:
F20:0661       	move.l  	(a0)+,(a1)				; Move long word from patterns into VDP
               S02:000009C6:  22 98
F20:0662       										; port and increment A0 by 4
F20:0663       	dbra    	d1,.1					; If D1 is not zero decrement and jump
               S02:000009C8:  51 C9 FF FC
F20:0664       										; back to 1
F20:0665           
F20:0666           rts									; Return to caller
               S02:000009CC:  4E 75
F20:0667       
F20:0668       
F20:0669       ;==============================================================================
F20:0670       ;
F20:0671       ; Set the tile ID of a sprite in the hw mirror table
F20:0672       ;
F20:0673       ; Input
F20:0674       ;	d0 = new tile ID
F20:0675       ;	a0 = the address of the sprite to modify
F20:0676       ;
F20:0677       ;==============================================================================
F20:0678       _rendSetSpriteTileID_Address:
F20:0679       	move.w		4(a0),d1
               S02:000009CE:  32 28 00 04
F20:0680       	and.w		#$07ff,d0		; Binary: 0000 0111 1111 1111
               S02:000009D2:  C0 7C 07 FF
F20:0681       	and.w		#$f800,d1		; Binary: 1111 1000 0000 0000
               S02:000009D6:  C2 7C F8 00
F20:0682       	or.w		d0,d1
               S02:000009DA:  82 40
F20:0683       	move.w		d1,4(a0)
               S02:000009DC:  31 41 00 04
F20:0684       	rts
               S02:000009E0:  4E 75
F20:0685       
F20:0686       
F20:0687       ;==============================================================================
F20:0688       ;
F20:0689       ; Set the width and height of a sprite in the hw mirror table
F20:0690       ;
F20:0691       ; Input
F20:0692       ;	d0 = width, in tiles
F20:0693       ;	d1 = height, in tiles
F20:0694       ;	a0 = the address of the sprite to modify
F20:0695       ;
F20:0696       ;==============================================================================
F20:0697       _rendSetSpriteDimensions_Address:
F20:0698       	push		d2
F53:0001       	move.l		d2,-(sp)
               S02:000009E2:  2F 02
F20:0699       	move.b		#0,d2
               S02:000009E4:  14 3C 00 00
F20:0700       	or			d1,d2
               S02:000009E8:  84 41
F20:0701       	lsl			#2,d0
               S02:000009EA:  E5 48
F20:0702       	or			d0,d2
               S02:000009EC:  84 40
F20:0703       	move.b		d2,2(a0)
               S02:000009EE:  11 42 00 02
F20:0704       	pop			d2
F54:0001       	move.l		(sp)+,d2
               S02:000009F2:  24 1F
F20:0705       	rts
               S02:000009F4:  4E 75
F20:0706       
F20:0707       
F20:0708       ;==============================================================================
F20:0709       ;
F20:0710       ; Set the X and Y coordinate of a sprite into the mirror table
F20:0711       ;
F20:0712       ; Input
F20:0713       ;	d0 = X position, in pixels. 0 is left most pixel on screen
F20:0714       ;	d1 = Y position, in pixels. 0 is top line on screen
F20:0715       ;	a0 = the address of the sprite to modify
F20:0716       ;
F20:0717       ;==============================================================================
F20:0718       _rendSetSpritePosition_Address:
F20:0719       	add.l		#$80,d0
               S02:000009F6:  D0 BC 00 00 00 80
F20:0720       	add.l		#$80,d1
               S02:000009FC:  D2 BC 00 00 00 80
F20:0721       	move.w		d1,(a0)
               S02:00000A02:  30 81
F20:0722       	move.w		d0,6(a0)
               S02:00000A04:  31 40 00 06
F20:0723       	rts
               S02:00000A08:  4E 75
F20:0724       
F20:0725       
F20:0726       ;==============================================================================
F20:0727       ;
F20:0728       ; Add sprite with index d0 to the render list.
F20:0729       ;
F20:0730       ; Input
F20:0731       ;	d0 = The sprite slot ID that should be added to the render list
F20:0732       ;
F20:0733       ;==============================================================================
F20:0734       _rendAddSprite_Index:
F20:0735       	push		d2
F55:0001       	move.l		d2,-(sp)
               S02:00000A0A:  2F 02
F20:0736       	move.l		d0,d2					; Retain the sprite slot index in d2
               S02:00000A0C:  24 00
F20:0737       
F20:0738       	sub.l		#1,d0					; We actually want to modify
               S02:00000A0E:  53 80
F20:0739       										; the sprite BEFORE this
F20:0740       	mulu		#_cpu_sprite_size,d0	; Calculate the byte offset to the sprite data
               S02:00000A10:  C0 FC 00 0E
F20:0741       
F20:0742       	;
F20:0743       	move.l		#VarHWSprites,d1		; Get base address to the sprite mirror table
               S02:00000A14:  22 3C 00 FF E0 1E
F20:0744       	add			d0,d1					; Add the offset to the sprite index before d0
               S02:00000A1A:  D2 40
F20:0745       	move.l		d1,a0					; We want to address it
               S02:00000A1C:  20 41
F20:0746       
F20:0747       	; a0 is now the address to the sprite slot in the sprite mirror table
F20:0748       	; d2 is the sprite index
F20:0749       
F20:0750       	move.b		d2,3(a0)
               S02:00000A1E:  11 42 00 03
F20:0751       
F20:0752       	; Refresh data in VRAM
F20:0753       	move.l		d2,d0
               S02:00000A22:  20 02
F20:0754       	sub			#1,d0
               S02:00000A24:  53 40
F20:0755       	jsr			_rendCopySpriteToVRAM_Index
               S02:00000A26:  61 04
F20:0756       
F20:0757       	pop			d2
F56:0001       	move.l		(sp)+,d2
               S02:00000A28:  24 1F
F20:0758       	rts
               S02:00000A2A:  4E 75
F20:0759       
F20:0760       
F20:0761       ;==============================================================================
F20:0762       ;
F20:0763       ; Copy the sprite mirror table entry from CPU RAM to VRAM
F20:0764       ;
F20:0765       ; Input
F20:0766       ;	d0 = Sprite entry index. Allowed range is 0-79
F20:0767       ;
F20:0768       ;==============================================================================
F20:0769       _rendCopySpriteToVRAM_Index:
F20:0770       	push		d0
F57:0001       	move.l		d0,-(sp)
               S02:00000A2C:  2F 00
F20:0771       
F20:0772       	move.l		#VRAM_SpriteAttributes_Start,d1
               S02:00000A2E:  22 3C 00 00 B8 00
F20:0773       	mulu		#hw_sprite_byte_size,d0
               S02:00000A34:  C0 FC 00 08
F20:0774       	add.l		d1,d0
               S02:00000A38:  D0 81
F20:0775       	jsr			_rendIntegerToVRAMAddress
               S02:00000A3A:  61 26
F20:0776       	; Now d0 is the destination address in VRAM
F20:0777       
F20:0778       	move.l		#$00C00004,a0
               S02:00000A3C:  20 7C 00 C0 00 04
F20:0779       	move.w		#$8F02,(a0)			; Set autoincrement (register 15) to 2
               S02:00000A42:  30 BC 8F 02
F20:0780       	move.l		d0,(a0)				; Set destination address in VRAM
               S02:00000A46:  20 80
F20:0781       
F20:0782       	; Get the source address
F20:0783       	pop			d0
F58:0001       	move.l		(sp)+,d0
               S02:00000A48:  20 1F
F20:0784       	mulu		#_cpu_sprite_size,d0
               S02:00000A4A:  C0 FC 00 0E
F20:0785       	add.l		#VarHWSprites,d0
               S02:00000A4E:  D0 BC 00 FF E0 1E
F20:0786       	move.l		d0,a0
               S02:00000A54:  20 40
F20:0787       	; Now a0 is the source
F20:0788       
F20:0789       	; Data write register
F20:0790       	move.l		#$00C00000,a1
               S02:00000A56:  22 7C 00 C0 00 00
F20:0791       
F20:0792       	; Copy the sprite settings
F20:0793       	move.l		(a0)+,(a1)
               S02:00000A5C:  22 98
F20:0794       	move.l		(a0)+,(a1)
               S02:00000A5E:  22 98
F20:0795       
F20:0796       	rts
               S02:00000A60:  4E 75
F20:0797       
F20:0798       
F20:0799       ;==============================================================================
F20:0800       ;
F20:0801       ; Translate a regular integer to a Mega Drive VRAM address
F20:0802       ;
F20:0803       ; Input:
F20:0804       ; d0 = original address
F20:0805       ;
F20:0806       ; Output:
F20:0807       ; d0 = Mega Drive "scrambled" address
F20:0808       ;
F20:0809       ; Source bits look like this
F20:0810       ; A31 A30 A29 A28 A27 A26 A25 A24 A23 A22 A21 A20 A19 A18 A17 A16
F20:0811       ; A15 A14 A13 A12 A11 A10 A09 A08 A07 A06 A05 A04 A03 A02 A01 A00
F20:0812       ;
F20:0813       ; Destination bits look like this
F20:0814       ; CD1 CD0 A13 A12 A11 A10 A09 A08 A07 A06 A05 A04 A03 A02 A01 A00
F20:0815       ;   0   0   0   0   0   0   0   0   0   0   0 CD2   0   0 A15 A14
F20:0816       ;
F20:0817       ; So only the bottom 16 bits of the source are used, and they are
F20:0818       ; shuffled around. Then a mask is added on top of that to indicate
F20:0819       ; a VRAM write.
F20:0820       ;
F20:0821       ;==============================================================================
F20:0822       _rendIntegerToVRAMAddress:
F20:0823       	move.l	d0,d1
               S02:00000A62:  22 00
F20:0824       	and.l	#$3fff,d0
               S02:00000A64:  C0 BC 00 00 3F FF
F20:0825       	lsr.l	#7,d1		; Shift 14 bits right, but since it isn't possible to shift
               S02:00000A6A:  EE 89
F20:0826       	lsr.l	#7,d1		; more than 8 bits at a time I do two instructions instead
               S02:00000A6C:  EE 89
F20:0827       	lsl.l	#8,d0		; Shift 16 bits to the left
               S02:00000A6E:  E1 88
F20:0828       	lsl.l	#8,d0
               S02:00000A70:  E1 88
F20:0829       	and.l	#3,d1
               S02:00000A72:  C2 BC 00 00 00 03
F20:0830       	or.l	d1,d0
               S02:00000A78:  80 81
F20:0831       	or.l	#$40000000,d0
               S02:00000A7A:  80 BC 40 00 00 00
F20:0832       	rts
               S02:00000A80:  4E 75
F20:0833       
F20:0834       
F20:0835       
F20:0836       
F20:0837       
F20:0838       ;==============================================================================
F20:0839       ;
F20:0840       ; Helper routines
F20:0841       ;
F20:0842       ;==============================================================================
F20:0843       InitVDP:
F20:0844       	moveq		#18,d0						; 24 registers, but we set only 18
               S02:00000A82:  70 12
F20:0845       	lea			VDPRegs,a0					; start address of register values
               S02:00000A84:  41 FA 00 14
F20:0846       	move.l		#$00C00004,a4				; The VDP control register
               S02:00000A88:  28 7C 00 C0 00 04
F20:0847       	clr.l		d5
               S02:00000A8E:  7A 00
F20:0848       
F20:0849       .loop:
F20:0850       	move.w		(a0)+,d5					; load lower byte (register value)
               S02:00000A90:  3A 18
F20:0851       	move.w		d5,(a4)						; write register
               S02:00000A92:  38 85
F20:0852       	dbra		d0,.loop					; loop
               S02:00000A94:  51 C8 FF FA
F20:0853       
F20:0854       	rts										; Jump back to caller
               S02:00000A98:  4E 75
F20:0855       
F20:0856       VDPRegs:
F20:0857       	dc.w		$8004						; Reg.  0: Enable Hint, HV counter stop
               S02:00000A9A:  80 04
F20:0858       	dc.w		$8174						; Reg.  1: Enable display, enable Vint, enable DMA, V28 mode (PAL & NTSC)
               S02:00000A9C:  81 74
F20:0859       	dc.b		$82							; Reg.  2: Plane A tile map
               S02:00000A9E:  82
F20:0860       	dc.b		VRAM_TileMap0_Start>>10
               S02:00000A9F:  30
F20:0861       	dc.w		$8340						; Reg.  3: Window is at $10000 (disable)
               S02:00000AA0:  83 40
F20:0862       	dc.b		$84							; Reg.  4: Plane B tile map
               S02:00000AA2:  84
F20:0863       	dc.b		VRAM_TileMap1_Start>>13
               S02:00000AA3:  07
F20:0864       	dc.b		$85							; Reg.  5: Sprite attribute table
               S02:00000AA4:  85
F20:0865       	dc.b		VRAM_SpriteAttributes_Start>>9
               S02:00000AA5:  5C
F20:0866       	dc.w		$8600						; Reg.  6: always zero
               S02:00000AA6:  86 00
F20:0867       	dc.w		$8700						; Reg.  7: Background color: palette 0, color 0
               S02:00000AA8:  87 00
F20:0868       	dc.w		$8800						; Reg.  8: always zero
               S02:00000AAA:  88 00
F20:0869       	dc.w		$8900						; Reg.  9: always zero
               S02:00000AAC:  89 00
F20:0870       	dc.w		$8a00						; Reg. 10: Hint timing
               S02:00000AAE:  8A 00
F20:0871       	dc.w		$8b08						; Reg. 11: Enable Eint, full scroll
               S02:00000AB0:  8B 08
F20:0872       	dc.w		$8c81						; Reg. 12: Disable Shadow/Highlight, no interlace, 40 cell mode
               S02:00000AB2:  8C 81
F20:0873       	dc.b		$8d							; Reg. 13: Horizontal scroll table
               S02:00000AB4:  8D
F20:0874       	dc.b		VRAM_HScroll_Start>>10
               S02:00000AB5:  2F
F20:0875       	dc.w		$8e00						; Reg. 14: always zero
               S02:00000AB6:  8E 00
F20:0876       	dc.w		$8f00						; Reg. 15: no autoincrement
               S02:00000AB8:  8F 00
F20:0877       	dc.w		$9000						; Reg. 16: Scroll 32V and 32H
               S02:00000ABA:  90 00
F20:0878       	dc.w		$9100						; Reg. 17: Set window X position/size to 0
               S02:00000ABC:  91 00
F20:0879       	dc.w		$9200						; Reg. 18: Set window Y position/size to 0
               S02:00000ABE:  92 00
F20:0880       	dc.w		$9300						; Reg. 19: DMA counter low
               S02:00000AC0:  93 00
F20:0881       	dc.w		$9400						; Reg. 20: DMA counter high
               S02:00000AC2:  94 00
F20:0882       	dc.w		$9500						; Reg. 21: DMA source address low
               S02:00000AC4:  95 00
F20:0883       	dc.w		$9600						; Reg. 22: DMA source address mid
               S02:00000AC6:  96 00
F20:0884       	dc.w		$9700						; Reg. 23: DMA source address high, DMA mode ?
               S02:00000AC8:  97 00
F20:0885       
F00:0014       	include		"../src/platform/megadrive/file.asm"
F59:0001       ;==============================================================================
F59:0002       ;
F59:0003       ; Get the address to a file
F59:0004       ;
F59:0005       ; Input:
F59:0006       ;	d0=file ID
F59:0007       ;
F59:0008       ; Output
F59:0009       ;	a0=address to file data
F59:0010       ;	d0=file size
F59:0011       ;
F59:0012       ;==============================================================================
F59:0013       fileLoad:
F59:0014       	lea			FileIDMap,a0
               S02:00000ACA:  41 F9 00 01 AC 02
F59:0015       	mulu		#4,d0
               S02:00000AD0:  C0 FC 00 04
F59:0016       	add.l		d0,a0
               S02:00000AD4:  D1 C0
F59:0017       	clr.l		d0
               S02:00000AD6:  70 00
F59:0018       	clr.l		d1
               S02:00000AD8:  72 00
F59:0019       	move.w		(a0)+,d0		; Read offset
               S02:00000ADA:  30 18
F59:0020       	move.w		(a0)+,d1		; Read size
               S02:00000ADC:  32 18
F59:0021       
F59:0022       	mulu		#_chunk_size,d0	; Offset is not in bytes but in X byte chunks. Correct that.
               S02:00000ADE:  C0 FC 00 80
F59:0023       	move.l		d0,a0			; Move the corrected address into the return register
               S02:00000AE2:  20 40
F59:0024       
F59:0025       	move.l		d1,d0			; Move file size into d0
               S02:00000AE4:  20 01
F59:0026       
F59:0027       	rts
               S02:00000AE6:  4E 75
F59:0028       
F00:0015       	include		"../src/platform/megadrive/img.asm"
F60:0001       ; a0 = Pointer to image data to load
F60:0002       imgLoad:
F60:0003       	; Load tile bank first
F60:0004       	move	#0,d0				; Since I don't know how to fetch a word and clear the top bits I do this first
               S02:00000AE8:  30 3C 00 00
F60:0005       	move.w	(a0)+,d0			; Fetch file ID of the tile bank and load it
               S02:00000AEC:  30 18
F60:0006       	move	#0,d1				; Destination address in VRAM
               S02:00000AEE:  32 3C 00 00
F60:0007       	move.l	a0,-(sp)
               S02:00000AF2:  2F 08
F60:0008       	jsr		rendLoadTileBank
               S02:00000AF4:  61 00 FC 92
F60:0009       	move.l	(sp)+,a0
               S02:00000AF8:  20 5F
F60:0010       
F60:0011       	; Load map
F60:0012       	move.w	(a0)+,d0			; Fetch file ID of the tile bank and load it
               S02:00000AFA:  30 18
F60:0013       	move	#0,d1				; #0 is the background layer
               S02:00000AFC:  32 3C 00 00
F60:0014       	move.l	a0,-(sp)
               S02:00000B00:  2F 08
F60:0015       	jsr		rendLoadTileMap
               S02:00000B02:  61 00 FD F2
F60:0016       	move.l	(sp)+,a0
               S02:00000B06:  20 5F
F60:0017       
F60:0018       	; Load palette
F60:0019       	move.w	(a0)+,d0			; Fetch file ID of the tile bank and load it
               S02:00000B08:  30 18
F60:0020       	move	#0,d1				; #0 is the background palette
               S02:00000B0A:  32 3C 00 00
F60:0021       	move.l	a0,-(sp)
               S02:00000B0E:  2F 08
F60:0022       	jsr		rendLoadPalette
               S02:00000B10:  61 00 FE 64
F60:0023       	move.l	(sp)+,a0
               S02:00000B14:  20 5F
F60:0024       
F60:0025       	rts
               S02:00000B16:  4E 75
F60:0026       
F00:0016       	include		"../src/incasm/data.asm"
F61:0001       	; Various tables
F61:0002       	include		"../src/incasm/sintable.asm"
F62:0001       sintable:
F62:0002       	dc.w	$0000
               S02:00000B18:  00 00
F62:0003       	dc.w	$0006
               S02:00000B1A:  00 06
F62:0004       	dc.w	$000c
               S02:00000B1C:  00 0C
F62:0005       	dc.w	$0012
               S02:00000B1E:  00 12
F62:0006       	dc.w	$0019
               S02:00000B20:  00 19
F62:0007       	dc.w	$001f
               S02:00000B22:  00 1F
F62:0008       	dc.w	$0025
               S02:00000B24:  00 25
F62:0009       	dc.w	$002b
               S02:00000B26:  00 2B
F62:0010       	dc.w	$0031
               S02:00000B28:  00 31
F62:0011       	dc.w	$0038
               S02:00000B2A:  00 38
F62:0012       	dc.w	$003e
               S02:00000B2C:  00 3E
F62:0013       	dc.w	$0044
               S02:00000B2E:  00 44
F62:0014       	dc.w	$004a
               S02:00000B30:  00 4A
F62:0015       	dc.w	$0050
               S02:00000B32:  00 50
F62:0016       	dc.w	$0056
               S02:00000B34:  00 56
F62:0017       	dc.w	$005c
               S02:00000B36:  00 5C
F62:0018       	dc.w	$0061
               S02:00000B38:  00 61
F62:0019       	dc.w	$0067
               S02:00000B3A:  00 67
F62:0020       	dc.w	$006d
               S02:00000B3C:  00 6D
F62:0021       	dc.w	$0073
               S02:00000B3E:  00 73
F62:0022       	dc.w	$0078
               S02:00000B40:  00 78
F62:0023       	dc.w	$007e
               S02:00000B42:  00 7E
F62:0024       	dc.w	$0083
               S02:00000B44:  00 83
F62:0025       	dc.w	$0088
               S02:00000B46:  00 88
F62:0026       	dc.w	$008e
               S02:00000B48:  00 8E
F62:0027       	dc.w	$0093
               S02:00000B4A:  00 93
F62:0028       	dc.w	$0098
               S02:00000B4C:  00 98
F62:0029       	dc.w	$009d
               S02:00000B4E:  00 9D
F62:0030       	dc.w	$00a2
               S02:00000B50:  00 A2
F62:0031       	dc.w	$00a7
               S02:00000B52:  00 A7
F62:0032       	dc.w	$00ab
               S02:00000B54:  00 AB
F62:0033       	dc.w	$00b0
               S02:00000B56:  00 B0
F62:0034       	dc.w	$00b5
               S02:00000B58:  00 B5
F62:0035       	dc.w	$00b9
               S02:00000B5A:  00 B9
F62:0036       	dc.w	$00bd
               S02:00000B5C:  00 BD
F62:0037       	dc.w	$00c1
               S02:00000B5E:  00 C1
F62:0038       	dc.w	$00c5
               S02:00000B60:  00 C5
F62:0039       	dc.w	$00c9
               S02:00000B62:  00 C9
F62:0040       	dc.w	$00cd
               S02:00000B64:  00 CD
F62:0041       	dc.w	$00d1
               S02:00000B66:  00 D1
F62:0042       	dc.w	$00d4
               S02:00000B68:  00 D4
F62:0043       	dc.w	$00d8
               S02:00000B6A:  00 D8
F62:0044       	dc.w	$00db
               S02:00000B6C:  00 DB
F62:0045       	dc.w	$00de
               S02:00000B6E:  00 DE
F62:0046       	dc.w	$00e1
               S02:00000B70:  00 E1
F62:0047       	dc.w	$00e4
               S02:00000B72:  00 E4
F62:0048       	dc.w	$00e7
               S02:00000B74:  00 E7
F62:0049       	dc.w	$00ea
               S02:00000B76:  00 EA
F62:0050       	dc.w	$00ec
               S02:00000B78:  00 EC
F62:0051       	dc.w	$00ee
               S02:00000B7A:  00 EE
F62:0052       	dc.w	$00f1
               S02:00000B7C:  00 F1
F62:0053       	dc.w	$00f3
               S02:00000B7E:  00 F3
F62:0054       	dc.w	$00f4
               S02:00000B80:  00 F4
F62:0055       	dc.w	$00f6
               S02:00000B82:  00 F6
F62:0056       	dc.w	$00f8
               S02:00000B84:  00 F8
F62:0057       	dc.w	$00f9
               S02:00000B86:  00 F9
F62:0058       	dc.w	$00fb
               S02:00000B88:  00 FB
F62:0059       	dc.w	$00fc
               S02:00000B8A:  00 FC
F62:0060       	dc.w	$00fd
               S02:00000B8C:  00 FD
F62:0061       	dc.w	$00fe
               S02:00000B8E:  00 FE
F62:0062       	dc.w	$00fe
               S02:00000B90:  00 FE
F62:0063       	dc.w	$00ff
               S02:00000B92:  00 FF
F62:0064       	dc.w	$00ff
               S02:00000B94:  00 FF
F62:0065       	dc.w	$00ff
               S02:00000B96:  00 FF
F62:0066       	dc.w	$0100
               S02:00000B98:  01 00
F62:0067       	dc.w	$00ff
               S02:00000B9A:  00 FF
F62:0068       	dc.w	$00ff
               S02:00000B9C:  00 FF
F62:0069       	dc.w	$00ff
               S02:00000B9E:  00 FF
F62:0070       	dc.w	$00fe
               S02:00000BA0:  00 FE
F62:0071       	dc.w	$00fe
               S02:00000BA2:  00 FE
F62:0072       	dc.w	$00fd
               S02:00000BA4:  00 FD
F62:0073       	dc.w	$00fc
               S02:00000BA6:  00 FC
F62:0074       	dc.w	$00fb
               S02:00000BA8:  00 FB
F62:0075       	dc.w	$00f9
               S02:00000BAA:  00 F9
F62:0076       	dc.w	$00f8
               S02:00000BAC:  00 F8
F62:0077       	dc.w	$00f6
               S02:00000BAE:  00 F6
F62:0078       	dc.w	$00f4
               S02:00000BB0:  00 F4
F62:0079       	dc.w	$00f3
               S02:00000BB2:  00 F3
F62:0080       	dc.w	$00f1
               S02:00000BB4:  00 F1
F62:0081       	dc.w	$00ee
               S02:00000BB6:  00 EE
F62:0082       	dc.w	$00ec
               S02:00000BB8:  00 EC
F62:0083       	dc.w	$00ea
               S02:00000BBA:  00 EA
F62:0084       	dc.w	$00e7
               S02:00000BBC:  00 E7
F62:0085       	dc.w	$00e4
               S02:00000BBE:  00 E4
F62:0086       	dc.w	$00e1
               S02:00000BC0:  00 E1
F62:0087       	dc.w	$00de
               S02:00000BC2:  00 DE
F62:0088       	dc.w	$00db
               S02:00000BC4:  00 DB
F62:0089       	dc.w	$00d8
               S02:00000BC6:  00 D8
F62:0090       	dc.w	$00d4
               S02:00000BC8:  00 D4
F62:0091       	dc.w	$00d1
               S02:00000BCA:  00 D1
F62:0092       	dc.w	$00cd
               S02:00000BCC:  00 CD
F62:0093       	dc.w	$00c9
               S02:00000BCE:  00 C9
F62:0094       	dc.w	$00c5
               S02:00000BD0:  00 C5
F62:0095       	dc.w	$00c1
               S02:00000BD2:  00 C1
F62:0096       	dc.w	$00bd
               S02:00000BD4:  00 BD
F62:0097       	dc.w	$00b9
               S02:00000BD6:  00 B9
F62:0098       	dc.w	$00b5
               S02:00000BD8:  00 B5
F62:0099       	dc.w	$00b0
               S02:00000BDA:  00 B0
F62:0100       	dc.w	$00ab
               S02:00000BDC:  00 AB
F62:0101       	dc.w	$00a7
               S02:00000BDE:  00 A7
F62:0102       	dc.w	$00a2
               S02:00000BE0:  00 A2
F62:0103       	dc.w	$009d
               S02:00000BE2:  00 9D
F62:0104       	dc.w	$0098
               S02:00000BE4:  00 98
F62:0105       	dc.w	$0093
               S02:00000BE6:  00 93
F62:0106       	dc.w	$008e
               S02:00000BE8:  00 8E
F62:0107       	dc.w	$0088
               S02:00000BEA:  00 88
F62:0108       	dc.w	$0083
               S02:00000BEC:  00 83
F62:0109       	dc.w	$007e
               S02:00000BEE:  00 7E
F62:0110       	dc.w	$0078
               S02:00000BF0:  00 78
F62:0111       	dc.w	$0073
               S02:00000BF2:  00 73
F62:0112       	dc.w	$006d
               S02:00000BF4:  00 6D
F62:0113       	dc.w	$0067
               S02:00000BF6:  00 67
F62:0114       	dc.w	$0061
               S02:00000BF8:  00 61
F62:0115       	dc.w	$005c
               S02:00000BFA:  00 5C
F62:0116       	dc.w	$0056
               S02:00000BFC:  00 56
F62:0117       	dc.w	$0050
               S02:00000BFE:  00 50
F62:0118       	dc.w	$004a
               S02:00000C00:  00 4A
F62:0119       	dc.w	$0044
               S02:00000C02:  00 44
F62:0120       	dc.w	$003e
               S02:00000C04:  00 3E
F62:0121       	dc.w	$0038
               S02:00000C06:  00 38
F62:0122       	dc.w	$0031
               S02:00000C08:  00 31
F62:0123       	dc.w	$002b
               S02:00000C0A:  00 2B
F62:0124       	dc.w	$0025
               S02:00000C0C:  00 25
F62:0125       	dc.w	$001f
               S02:00000C0E:  00 1F
F62:0126       	dc.w	$0019
               S02:00000C10:  00 19
F62:0127       	dc.w	$0012
               S02:00000C12:  00 12
F62:0128       	dc.w	$000c
               S02:00000C14:  00 0C
F62:0129       	dc.w	$0006
               S02:00000C16:  00 06
F62:0130       	dc.w	$0000
               S02:00000C18:  00 00
F62:0131       	dc.w	$fffa
               S02:00000C1A:  FF FA
F62:0132       	dc.w	$fff4
               S02:00000C1C:  FF F4
F62:0133       	dc.w	$ffee
               S02:00000C1E:  FF EE
F62:0134       	dc.w	$ffe7
               S02:00000C20:  FF E7
F62:0135       	dc.w	$ffe1
               S02:00000C22:  FF E1
F62:0136       	dc.w	$ffdb
               S02:00000C24:  FF DB
F62:0137       	dc.w	$ffd5
               S02:00000C26:  FF D5
F62:0138       	dc.w	$ffcf
               S02:00000C28:  FF CF
F62:0139       	dc.w	$ffc8
               S02:00000C2A:  FF C8
F62:0140       	dc.w	$ffc2
               S02:00000C2C:  FF C2
F62:0141       	dc.w	$ffbc
               S02:00000C2E:  FF BC
F62:0142       	dc.w	$ffb6
               S02:00000C30:  FF B6
F62:0143       	dc.w	$ffb0
               S02:00000C32:  FF B0
F62:0144       	dc.w	$ffaa
               S02:00000C34:  FF AA
F62:0145       	dc.w	$ffa4
               S02:00000C36:  FF A4
F62:0146       	dc.w	$ff9f
               S02:00000C38:  FF 9F
F62:0147       	dc.w	$ff99
               S02:00000C3A:  FF 99
F62:0148       	dc.w	$ff93
               S02:00000C3C:  FF 93
F62:0149       	dc.w	$ff8d
               S02:00000C3E:  FF 8D
F62:0150       	dc.w	$ff88
               S02:00000C40:  FF 88
F62:0151       	dc.w	$ff82
               S02:00000C42:  FF 82
F62:0152       	dc.w	$ff7d
               S02:00000C44:  FF 7D
F62:0153       	dc.w	$ff78
               S02:00000C46:  FF 78
F62:0154       	dc.w	$ff72
               S02:00000C48:  FF 72
F62:0155       	dc.w	$ff6d
               S02:00000C4A:  FF 6D
F62:0156       	dc.w	$ff68
               S02:00000C4C:  FF 68
F62:0157       	dc.w	$ff63
               S02:00000C4E:  FF 63
F62:0158       	dc.w	$ff5e
               S02:00000C50:  FF 5E
F62:0159       	dc.w	$ff59
               S02:00000C52:  FF 59
F62:0160       	dc.w	$ff55
               S02:00000C54:  FF 55
F62:0161       	dc.w	$ff50
               S02:00000C56:  FF 50
F62:0162       	dc.w	$ff4c
               S02:00000C58:  FF 4C
F62:0163       	dc.w	$ff47
               S02:00000C5A:  FF 47
F62:0164       	dc.w	$ff43
               S02:00000C5C:  FF 43
F62:0165       	dc.w	$ff3f
               S02:00000C5E:  FF 3F
F62:0166       	dc.w	$ff3b
               S02:00000C60:  FF 3B
F62:0167       	dc.w	$ff37
               S02:00000C62:  FF 37
F62:0168       	dc.w	$ff33
               S02:00000C64:  FF 33
F62:0169       	dc.w	$ff2f
               S02:00000C66:  FF 2F
F62:0170       	dc.w	$ff2c
               S02:00000C68:  FF 2C
F62:0171       	dc.w	$ff28
               S02:00000C6A:  FF 28
F62:0172       	dc.w	$ff25
               S02:00000C6C:  FF 25
F62:0173       	dc.w	$ff22
               S02:00000C6E:  FF 22
F62:0174       	dc.w	$ff1f
               S02:00000C70:  FF 1F
F62:0175       	dc.w	$ff1c
               S02:00000C72:  FF 1C
F62:0176       	dc.w	$ff19
               S02:00000C74:  FF 19
F62:0177       	dc.w	$ff16
               S02:00000C76:  FF 16
F62:0178       	dc.w	$ff14
               S02:00000C78:  FF 14
F62:0179       	dc.w	$ff12
               S02:00000C7A:  FF 12
F62:0180       	dc.w	$ff0f
               S02:00000C7C:  FF 0F
F62:0181       	dc.w	$ff0d
               S02:00000C7E:  FF 0D
F62:0182       	dc.w	$ff0c
               S02:00000C80:  FF 0C
F62:0183       	dc.w	$ff0a
               S02:00000C82:  FF 0A
F62:0184       	dc.w	$ff08
               S02:00000C84:  FF 08
F62:0185       	dc.w	$ff07
               S02:00000C86:  FF 07
F62:0186       	dc.w	$ff05
               S02:00000C88:  FF 05
F62:0187       	dc.w	$ff04
               S02:00000C8A:  FF 04
F62:0188       	dc.w	$ff03
               S02:00000C8C:  FF 03
F62:0189       	dc.w	$ff02
               S02:00000C8E:  FF 02
F62:0190       	dc.w	$ff02
               S02:00000C90:  FF 02
F62:0191       	dc.w	$ff01
               S02:00000C92:  FF 01
F62:0192       	dc.w	$ff01
               S02:00000C94:  FF 01
F62:0193       	dc.w	$ff01
               S02:00000C96:  FF 01
F62:0194       	dc.w	$ff00
               S02:00000C98:  FF 00
F62:0195       	dc.w	$ff01
               S02:00000C9A:  FF 01
F62:0196       	dc.w	$ff01
               S02:00000C9C:  FF 01
F62:0197       	dc.w	$ff01
               S02:00000C9E:  FF 01
F62:0198       	dc.w	$ff02
               S02:00000CA0:  FF 02
F62:0199       	dc.w	$ff02
               S02:00000CA2:  FF 02
F62:0200       	dc.w	$ff03
               S02:00000CA4:  FF 03
F62:0201       	dc.w	$ff04
               S02:00000CA6:  FF 04
F62:0202       	dc.w	$ff05
               S02:00000CA8:  FF 05
F62:0203       	dc.w	$ff07
               S02:00000CAA:  FF 07
F62:0204       	dc.w	$ff08
               S02:00000CAC:  FF 08
F62:0205       	dc.w	$ff0a
               S02:00000CAE:  FF 0A
F62:0206       	dc.w	$ff0c
               S02:00000CB0:  FF 0C
F62:0207       	dc.w	$ff0d
               S02:00000CB2:  FF 0D
F62:0208       	dc.w	$ff0f
               S02:00000CB4:  FF 0F
F62:0209       	dc.w	$ff12
               S02:00000CB6:  FF 12
F62:0210       	dc.w	$ff14
               S02:00000CB8:  FF 14
F62:0211       	dc.w	$ff16
               S02:00000CBA:  FF 16
F62:0212       	dc.w	$ff19
               S02:00000CBC:  FF 19
F62:0213       	dc.w	$ff1c
               S02:00000CBE:  FF 1C
F62:0214       	dc.w	$ff1f
               S02:00000CC0:  FF 1F
F62:0215       	dc.w	$ff22
               S02:00000CC2:  FF 22
F62:0216       	dc.w	$ff25
               S02:00000CC4:  FF 25
F62:0217       	dc.w	$ff28
               S02:00000CC6:  FF 28
F62:0218       	dc.w	$ff2c
               S02:00000CC8:  FF 2C
F62:0219       	dc.w	$ff2f
               S02:00000CCA:  FF 2F
F62:0220       	dc.w	$ff33
               S02:00000CCC:  FF 33
F62:0221       	dc.w	$ff37
               S02:00000CCE:  FF 37
F62:0222       	dc.w	$ff3b
               S02:00000CD0:  FF 3B
F62:0223       	dc.w	$ff3f
               S02:00000CD2:  FF 3F
F62:0224       	dc.w	$ff43
               S02:00000CD4:  FF 43
F62:0225       	dc.w	$ff47
               S02:00000CD6:  FF 47
F62:0226       	dc.w	$ff4b
               S02:00000CD8:  FF 4B
F62:0227       	dc.w	$ff50
               S02:00000CDA:  FF 50
F62:0228       	dc.w	$ff55
               S02:00000CDC:  FF 55
F62:0229       	dc.w	$ff59
               S02:00000CDE:  FF 59
F62:0230       	dc.w	$ff5e
               S02:00000CE0:  FF 5E
F62:0231       	dc.w	$ff63
               S02:00000CE2:  FF 63
F62:0232       	dc.w	$ff68
               S02:00000CE4:  FF 68
F62:0233       	dc.w	$ff6d
               S02:00000CE6:  FF 6D
F62:0234       	dc.w	$ff72
               S02:00000CE8:  FF 72
F62:0235       	dc.w	$ff78
               S02:00000CEA:  FF 78
F62:0236       	dc.w	$ff7d
               S02:00000CEC:  FF 7D
F62:0237       	dc.w	$ff82
               S02:00000CEE:  FF 82
F62:0238       	dc.w	$ff88
               S02:00000CF0:  FF 88
F62:0239       	dc.w	$ff8d
               S02:00000CF2:  FF 8D
F62:0240       	dc.w	$ff93
               S02:00000CF4:  FF 93
F62:0241       	dc.w	$ff99
               S02:00000CF6:  FF 99
F62:0242       	dc.w	$ff9e
               S02:00000CF8:  FF 9E
F62:0243       	dc.w	$ffa4
               S02:00000CFA:  FF A4
F62:0244       	dc.w	$ffaa
               S02:00000CFC:  FF AA
F62:0245       	dc.w	$ffb0
               S02:00000CFE:  FF B0
F62:0246       	dc.w	$ffb6
               S02:00000D00:  FF B6
F62:0247       	dc.w	$ffbc
               S02:00000D02:  FF BC
F62:0248       	dc.w	$ffc2
               S02:00000D04:  FF C2
F62:0249       	dc.w	$ffc8
               S02:00000D06:  FF C8
F62:0250       	dc.w	$ffcf
               S02:00000D08:  FF CF
F62:0251       	dc.w	$ffd5
               S02:00000D0A:  FF D5
F62:0252       	dc.w	$ffdb
               S02:00000D0C:  FF DB
F62:0253       	dc.w	$ffe1
               S02:00000D0E:  FF E1
F62:0254       	dc.w	$ffe7
               S02:00000D10:  FF E7
F62:0255       	dc.w	$ffee
               S02:00000D12:  FF EE
F62:0256       	dc.w	$fff4
               S02:00000D14:  FF F4
F62:0257       	dc.w	$fffa
               S02:00000D16:  FF FA
F62:0258       
F61:0003       
F61:0004       	; Images
F61:0005       	include		"../src/incasm/testtiles_image.asm"
F63:0001       testtiles_image:
F63:0002       					dc.w		fileid_testtiles_bank
               S02:00000D18:  00 0C
F63:0003       					dc.w		fileid_testtiles_map
               S02:00000D1A:  00 0D
F63:0004       					dc.w		fileid_testtiles_palette
               S02:00000D1C:  00 0E
F63:0005       
F61:0006       	include		"../src/incasm/untitled_splash_image.asm"
F64:0001       untitled_splash_image:
F64:0002       					dc.w		fileid_untitled_splash_bank
               S02:00000D1E:  00 0F
F64:0003       					dc.w		fileid_untitled_splash_map
               S02:00000D20:  00 10
F64:0004       					dc.w		fileid_untitled_splash_palette
               S02:00000D22:  00 11
F64:0005       
F61:0007       
F61:0008       	; Game objects
F61:0009       	include		"../src/incasm/gameobject_hero.asm"
F65:0001       hero_go:
F65:0002       	dc.w		fileid_herotest_sprite_bank
               S02:00000D24:  00 00
F65:0003       	dc.w		fileid_herotest_sprite
               S02:00000D26:  00 02
F65:0004       
F65:0005       potion_go:
F65:0006       	dc.w		fileid_testsprite2_sprite_bank
               S02:00000D28:  00 09
F65:0007       	dc.w		fileid_testsprite2_sprite
               S02:00000D2A:  00 0B
F65:0008       
F61:0010       
F00:0017       
F00:0018       	org			$10000
F00:0019       
F00:0020       	include		"../src/incbin/data.asm"
F66:0001       
F66:0002       
F66:0003       ; herotest_sprite_bank.bin
F66:0004       
F66:0005       	cnop		0,_chunk_size
F66:0006       _data_herotest_sprite_bank:
F66:0007       	ifd	is_mega_drive
F66:0008       	incbin	"../src/incbin/herotest_sprite_bank.bin"
               S03:00010000:  00 04 00 11 11 11 01 55 66 51 15 66 66 61 16 66
               S03:00010010:  66 61 16 66 56 65 16 66 16 66 16 65 16 66 16 55
F66:0009       	else
F66:0010       	incbin	"../src/incbin/herotest_sprite_bank_amiga_b_hw.bin"
F66:0011       	endif
F66:0012       _data_herotest_sprite_bank_pos          equ _data_herotest_sprite_bank/_chunk_size
F66:0013       _data_herotest_sprite_bank_length       equ ((_data_herotest_sprite_bank_end-_data_herotest_sprite_bank)+(_chunk_size-1)
F66:0014       _data_herotest_sprite_bank_end:
F66:0015       
F66:0016       
F66:0017       ; herotest_palette.bin
F66:0018       
F66:0019       	cnop		0,_chunk_size
F66:0020       _data_herotest_palette:
F66:0021       	incbin	"../src/incbin/herotest_palette.bin"
               S03:00010100:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00010110:  02 A2 04 C4 0E 0E 0E 0E 0E 0E 0E 0E 00 AC 04 0E
F66:0022       _data_herotest_palette_pos              equ _data_herotest_palette/_chunk_size
F66:0023       _data_herotest_palette_length           equ ((_data_herotest_palette_end-_data_herotest_palette)+(_chunk_size-1))/_chunk
F66:0024       _data_herotest_palette_end:
F66:0025       
F66:0026       
F66:0027       ; herotest_sprite.bin
F66:0028       
F66:0029       	cnop		0,_chunk_size
F66:0030       _data_herotest_sprite:
F66:0031       	incbin	"../src/incbin/herotest_sprite.bin"
               S03:00010180:  10 10 01 00 DE AD 06
F66:0032       _data_herotest_sprite_pos               equ _data_herotest_sprite/_chunk_size
F66:0033       _data_herotest_sprite_length            equ ((_data_herotest_sprite_end-_data_herotest_sprite)+(_chunk_size-1))/_chunk_s
F66:0034       _data_herotest_sprite_end:
F66:0035       
F66:0036       
F66:0037       ; herotest_big_sprite_bank.bin
F66:0038       
F66:0039       	cnop		0,_chunk_size
F66:0040       _data_herotest_big_sprite_bank:
F66:0041       	ifd	is_mega_drive
F66:0042       	incbin	"../src/incbin/herotest_big_sprite_bank.bin"
               S03:00010200:  00 10 00 00 02 22 00 02 25 56 00 25 66 66 02 56
               S03:00010210:  64 46 02 66 46 66 25 64 66 66 25 66 66 65 26 66
F66:0043       	else
F66:0044       	incbin	"../src/incbin/herotest_big_sprite_bank_amiga_a_bob.bin"
F66:0045       	endif
F66:0046       _data_herotest_big_sprite_bank_pos      equ _data_herotest_big_sprite_bank/_chunk_size
F66:0047       _data_herotest_big_sprite_bank_length   equ ((_data_herotest_big_sprite_bank_end-_data_herotest_big_sprite_bank)+(_chunk
F66:0048       _data_herotest_big_sprite_bank_end:
F66:0049       
F66:0050       
F66:0051       ; herotest_big_palette.bin
F66:0052       
F66:0053       	cnop		0,_chunk_size
F66:0054       _data_herotest_big_palette:
F66:0055       	incbin	"../src/incbin/herotest_big_palette.bin"
               S03:00010480:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00010490:  02 A2 04 C4 0E 0E 0E 0E 0E 0E 0E 0E 00 AC 04 0E
F66:0056       _data_herotest_big_palette_pos          equ _data_herotest_big_palette/_chunk_size
F66:0057       _data_herotest_big_palette_length       equ ((_data_herotest_big_palette_end-_data_herotest_big_palette)+(_chunk_size-1)
F66:0058       _data_herotest_big_palette_end:
F66:0059       
F66:0060       
F66:0061       ; herotest_big_sprite.bin
F66:0062       
F66:0063       	cnop		0,_chunk_size
F66:0064       _data_herotest_big_sprite:
F66:0065       	incbin	"../src/incbin/herotest_big_sprite.bin"
               S03:00010500:  20 20 01 00 DE AD 06
F66:0066       _data_herotest_big_sprite_pos           equ _data_herotest_big_sprite/_chunk_size
F66:0067       _data_herotest_big_sprite_length        equ ((_data_herotest_big_sprite_end-_data_herotest_big_sprite)+(_chunk_size-1))/
F66:0068       _data_herotest_big_sprite_end:
F66:0069       
F66:0070       
F66:0071       ; testsprite_sprite_bank.bin
F66:0072       
F66:0073       	cnop		0,_chunk_size
F66:0074       _data_testsprite_sprite_bank:
F66:0075       	ifd	is_mega_drive
F66:0076       	incbin	"../src/incbin/testsprite_sprite_bank.bin"
               S03:00010580:  00 04 00 00 11 11 00 11 66 66 01 66 45 55 00 11
               S03:00010590:  55 55 00 00 11 11 00 01 66 65 00 01 64 65 00 16
F66:0077       	else
F66:0078       	incbin	"../src/incbin/testsprite_sprite_bank_amiga_a_bob.bin"
F66:0079       	endif
F66:0080       _data_testsprite_sprite_bank_pos        equ _data_testsprite_sprite_bank/_chunk_size
F66:0081       _data_testsprite_sprite_bank_length     equ ((_data_testsprite_sprite_bank_end-_data_testsprite_sprite_bank)+(_chunk_siz
F66:0082       _data_testsprite_sprite_bank_end:
F66:0083       
F66:0084       
F66:0085       ; testsprite_palette.bin
F66:0086       
F66:0087       	cnop		0,_chunk_size
F66:0088       _data_testsprite_palette:
F66:0089       	incbin	"../src/incbin/testsprite_palette.bin"
               S03:00010680:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00010690:  02 A2 04 C4 0E 0E 0E 0E 0E 0E 0E 0E 00 AC 04 0E
F66:0090       _data_testsprite_palette_pos            equ _data_testsprite_palette/_chunk_size
F66:0091       _data_testsprite_palette_length         equ ((_data_testsprite_palette_end-_data_testsprite_palette)+(_chunk_size-1))/_c
F66:0092       _data_testsprite_palette_end:
F66:0093       
F66:0094       
F66:0095       ; testsprite_sprite.bin
F66:0096       
F66:0097       	cnop		0,_chunk_size
F66:0098       _data_testsprite_sprite:
F66:0099       	incbin	"../src/incbin/testsprite_sprite.bin"
               S03:00010700:  10 10 01 00 DE AD 06
F66:0100       _data_testsprite_sprite_pos             equ _data_testsprite_sprite/_chunk_size
F66:0101       _data_testsprite_sprite_length          equ ((_data_testsprite_sprite_end-_data_testsprite_sprite)+(_chunk_size-1))/_chu
F66:0102       _data_testsprite_sprite_end:
F66:0103       
F66:0104       
F66:0105       ; testsprite2_sprite_bank.bin
F66:0106       
F66:0107       	cnop		0,_chunk_size
F66:0108       _data_testsprite2_sprite_bank:
F66:0109       	ifd	is_mega_drive
F66:0110       	incbin	"../src/incbin/testsprite2_sprite_bank.bin"
               S03:00010780:  00 08 00 00 11 11 00 11 55 55 01 55 11 55 00 11
               S03:00010790:  55 55 00 00 11 11 00 01 66 65 00 01 64 65 00 16
F66:0111       	else
F66:0112       	incbin	"../src/incbin/testsprite2_sprite_bank_amiga_a_bob.bin"
F66:0113       	endif
F66:0114       _data_testsprite2_sprite_bank_pos       equ _data_testsprite2_sprite_bank/_chunk_size
F66:0115       _data_testsprite2_sprite_bank_length    equ ((_data_testsprite2_sprite_bank_end-_data_testsprite2_sprite_bank)+(_chunk_s
F66:0116       _data_testsprite2_sprite_bank_end:
F66:0117       
F66:0118       
F66:0119       ; testsprite2_palette.bin
F66:0120       
F66:0121       	cnop		0,_chunk_size
F66:0122       _data_testsprite2_palette:
F66:0123       	incbin	"../src/incbin/testsprite2_palette.bin"
               S03:00010900:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00010910:  02 A2 04 C4 0E 0E 0E 0E 0E 0E 0E 0E 00 AC 04 0E
F66:0124       _data_testsprite2_palette_pos           equ _data_testsprite2_palette/_chunk_size
F66:0125       _data_testsprite2_palette_length        equ ((_data_testsprite2_palette_end-_data_testsprite2_palette)+(_chunk_size-1))/
F66:0126       _data_testsprite2_palette_end:
F66:0127       
F66:0128       
F66:0129       ; testsprite2_sprite.bin
F66:0130       
F66:0131       	cnop		0,_chunk_size
F66:0132       _data_testsprite2_sprite:
F66:0133       	incbin	"../src/incbin/testsprite2_sprite.bin"
               S03:00010980:  10 10 02 00 DE AD 05 03
F66:0134       _data_testsprite2_sprite_pos            equ _data_testsprite2_sprite/_chunk_size
F66:0135       _data_testsprite2_sprite_length         equ ((_data_testsprite2_sprite_end-_data_testsprite2_sprite)+(_chunk_size-1))/_c
F66:0136       _data_testsprite2_sprite_end:
F66:0137       
F66:0138       
F66:0139       ; testtiles_bank.bin
F66:0140       
F66:0141       	cnop		0,_chunk_size
F66:0142       _data_testtiles_bank:
F66:0143       	ifd	is_mega_drive
F66:0144       	incbin	"../src/incbin/testtiles_bank.bin"
               S03:00010A00:  00 4D 88 88 88 88 88 88 88 88 88 88 88 88 88 87
               S03:00010A10:  88 88 88 88 88 89 88 88 88 94 88 88 88 88 88 88
F66:0145       	else
F66:0146       	incbin	"../src/incbin/testtiles_bank_amiga.bin"
F66:0147       	endif
F66:0148       _data_testtiles_bank_pos                equ _data_testtiles_bank/_chunk_size
F66:0149       _data_testtiles_bank_length             equ ((_data_testtiles_bank_end-_data_testtiles_bank)+(_chunk_size-1))/_chunk_siz
F66:0150       _data_testtiles_bank_end:
F66:0151       
F66:0152       
F66:0153       ; testtiles_map.bin
F66:0154       
F66:0155       	cnop		0,_chunk_size
F66:0156       _data_testtiles_map:
F66:0157       	incbin	"../src/incbin/testtiles_map.bin"
               S03:00011400:  40 20 00 00 00 05 00 08 00 0D 00 10 00 14 00 04
               S03:00011410:  00 04 00 04 00 04 00 04 00 04 00 04 00 04 00 04
F66:0158       _data_testtiles_map_pos                 equ _data_testtiles_map/_chunk_size
F66:0159       _data_testtiles_map_length              equ ((_data_testtiles_map_end-_data_testtiles_map)+(_chunk_size-1))/_chunk_size
F66:0160       _data_testtiles_map_end:
F66:0161       
F66:0162       
F66:0163       ; testtiles_palette.bin
F66:0164       
F66:0165       	cnop		0,_chunk_size
F66:0166       _data_testtiles_palette:
F66:0167       	incbin	"../src/incbin/testtiles_palette.bin"
               S03:00012480:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00012490:  02 A2 04 C4 00 28 00 6A 0E 0E 0E 0E 02 8E 04 0E
F66:0168       _data_testtiles_palette_pos             equ _data_testtiles_palette/_chunk_size
F66:0169       _data_testtiles_palette_length          equ ((_data_testtiles_palette_end-_data_testtiles_palette)+(_chunk_size-1))/_chu
F66:0170       _data_testtiles_palette_end:
F66:0171       
F66:0172       
F66:0173       ; untitled_splash_bank.bin
F66:0174       
F66:0175       	cnop		0,_chunk_size
F66:0176       _data_untitled_splash_bank:
F66:0177       	ifd	is_mega_drive
F66:0178       	incbin	"../src/incbin/untitled_splash_bank.bin"
               S03:00012500:  00 6D 77 77 77 77 77 77 77 77 77 77 77 77 77 77
               S03:00012510:  77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77
F66:0179       	else
F66:0180       	incbin	"../src/incbin/untitled_splash_bank_amiga.bin"
F66:0181       	endif
F66:0182       _data_untitled_splash_bank_pos          equ _data_untitled_splash_bank/_chunk_size
F66:0183       _data_untitled_splash_bank_length       equ ((_data_untitled_splash_bank_end-_data_untitled_splash_bank)+(_chunk_size-1)
F66:0184       _data_untitled_splash_bank_end:
F66:0185       
F66:0186       
F66:0187       ; untitled_splash_map.bin
F66:0188       
F66:0189       	cnop		0,_chunk_size
F66:0190       _data_untitled_splash_map:
F66:0191       	incbin	"../src/incbin/untitled_splash_map.bin"
               S03:00013300:  40 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00
               S03:00013310:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
F66:0192       _data_untitled_splash_map_pos           equ _data_untitled_splash_map/_chunk_size
F66:0193       _data_untitled_splash_map_length        equ ((_data_untitled_splash_map_end-_data_untitled_splash_map)+(_chunk_size-1))/
F66:0194       _data_untitled_splash_map_end:
F66:0195       
F66:0196       
F66:0197       ; untitled_splash_palette.bin
F66:0198       
F66:0199       	cnop		0,_chunk_size
F66:0200       _data_untitled_splash_palette:
F66:0201       	incbin	"../src/incbin/untitled_splash_palette.bin"
               S03:00014380:  0E 0E 0E EE 0C CC 08 88 06 66 04 44 02 22 00 00
               S03:00014390:  0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E
F66:0202       _data_untitled_splash_palette_pos       equ _data_untitled_splash_palette/_chunk_size
F66:0203       _data_untitled_splash_palette_length    equ ((_data_untitled_splash_palette_end-_data_untitled_splash_palette)+(_chunk_s
F66:0204       _data_untitled_splash_palette_end:
F66:0205       
F66:0206       
F66:0207       ; herotestpng_sprite_bank.bin
F66:0208       
F66:0209       	cnop		0,_chunk_size
F66:0210       _data_herotestpng_sprite_bank:
F66:0211       	ifd	is_mega_drive
F66:0212       	incbin	"../src/incbin/herotestpng_sprite_bank.bin"
               S03:00014400:  00 04 00 11 11 11 01 55 66 51 15 66 66 61 16 66
               S03:00014410:  66 61 16 66 56 65 16 66 16 66 16 65 16 66 16 55
F66:0213       	else
F66:0214       	incbin	"../src/incbin/herotestpng_sprite_bank_amiga_a_bob.bin"
F66:0215       	endif
F66:0216       _data_herotestpng_sprite_bank_pos       equ _data_herotestpng_sprite_bank/_chunk_size
F66:0217       _data_herotestpng_sprite_bank_length    equ ((_data_herotestpng_sprite_bank_end-_data_herotestpng_sprite_bank)+(_chunk_s
F66:0218       _data_herotestpng_sprite_bank_end:
F66:0219       
F66:0220       
F66:0221       ; herotestpng_palette.bin
F66:0222       
F66:0223       	cnop		0,_chunk_size
F66:0224       _data_herotestpng_palette:
F66:0225       	incbin	"../src/incbin/herotestpng_palette.bin"
               S03:00014500:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00014510:  02 A2 04 C4 0E 0E 0E 0E 0E 0E 0E 0E 00 AC 04 0E
F66:0226       _data_herotestpng_palette_pos           equ _data_herotestpng_palette/_chunk_size
F66:0227       _data_herotestpng_palette_length        equ ((_data_herotestpng_palette_end-_data_herotestpng_palette)+(_chunk_size-1))/
F66:0228       _data_herotestpng_palette_end:
F66:0229       
F66:0230       
F66:0231       ; herotestpng_sprite.bin
F66:0232       
F66:0233       	cnop		0,_chunk_size
F66:0234       _data_herotestpng_sprite:
F66:0235       	incbin	"../src/incbin/herotestpng_sprite.bin"
               S03:00014580:  10 10 01 00 DE AD 06
F66:0236       _data_herotestpng_sprite_pos            equ _data_herotestpng_sprite/_chunk_size
F66:0237       _data_herotestpng_sprite_length         equ ((_data_herotestpng_sprite_end-_data_herotestpng_sprite)+(_chunk_size-1))/_c
F66:0238       _data_herotestpng_sprite_end:
F66:0239       
F66:0240       
F66:0241       ; housetiles_bank.bin
F66:0242       
F66:0243       	cnop		0,_chunk_size
F66:0244       _data_housetiles_bank:
F66:0245       	ifd	is_mega_drive
F66:0246       	incbin	"../src/incbin/housetiles_bank.bin"
               S03:00014600:  00 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00
               S03:00014610:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
F66:0247       	else
F66:0248       	incbin	"../src/incbin/housetiles_bank_amiga.bin"
F66:0249       	endif
F66:0250       _data_housetiles_bank_pos               equ _data_housetiles_bank/_chunk_size
F66:0251       _data_housetiles_bank_length            equ ((_data_housetiles_bank_end-_data_housetiles_bank)+(_chunk_size-1))/_chunk_s
F66:0252       _data_housetiles_bank_end:
F66:0253       
F66:0254       
F66:0255       ; housetiles_map.bin
F66:0256       
F66:0257       	cnop		0,_chunk_size
F66:0258       _data_housetiles_map:
F66:0259       	incbin	"../src/incbin/housetiles_map.bin"
               S03:00014880:  40 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00
               S03:00014890:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
F66:0260       _data_housetiles_map_pos                equ _data_housetiles_map/_chunk_size
F66:0261       _data_housetiles_map_length             equ ((_data_housetiles_map_end-_data_housetiles_map)+(_chunk_size-1))/_chunk_siz
F66:0262       _data_housetiles_map_end:
F66:0263       
F66:0264       
F66:0265       ; housetiles_palette.bin
F66:0266       
F66:0267       	cnop		0,_chunk_size
F66:0268       _data_housetiles_palette:
F66:0269       	incbin	"../src/incbin/housetiles_palette.bin"
               S03:00015900:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00015910:  02 A2 04 C4 00 28 00 6A 00 EE 0E 0E 02 8E 04 0E
F66:0270       _data_housetiles_palette_pos            equ _data_housetiles_palette/_chunk_size
F66:0271       _data_housetiles_palette_length         equ ((_data_housetiles_palette_end-_data_housetiles_palette)+(_chunk_size-1))/_c
F66:0272       _data_housetiles_palette_end:
F66:0273       
F66:0274       
F66:0275       ; signpost_bank.bin
F66:0276       
F66:0277       	cnop		0,_chunk_size
F66:0278       _data_signpost_bank:
F66:0279       	ifd	is_mega_drive
F66:0280       	incbin	"../src/incbin/signpost_bank.bin"
               S03:00015980:  00 04 00 00 00 00 00 00 00 0B 00 00 00 BB 00 00
               S03:00015990:  00 EE 00 BB BB BB 0B B1 2B 1B 0B B1 B1 2B 0B BB
F66:0281       	else
F66:0282       	incbin	"../src/incbin/signpost_bank_amiga.bin"
F66:0283       	endif
F66:0284       _data_signpost_bank_pos                 equ _data_signpost_bank/_chunk_size
F66:0285       _data_signpost_bank_length              equ ((_data_signpost_bank_end-_data_signpost_bank)+(_chunk_size-1))/_chunk_size
F66:0286       _data_signpost_bank_end:
F66:0287       
F66:0288       
F66:0289       ; signpost_map.bin
F66:0290       
F66:0291       	cnop		0,_chunk_size
F66:0292       _data_signpost_map:
F66:0293       	incbin	"../src/incbin/signpost_map.bin"
               S03:00015A80:  40 20 00 00 00 02 00 00 00 00 00 00 00 00 00 00
               S03:00015A90:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
F66:0294       _data_signpost_map_pos                  equ _data_signpost_map/_chunk_size
F66:0295       _data_signpost_map_length               equ ((_data_signpost_map_end-_data_signpost_map)+(_chunk_size-1))/_chunk_size
F66:0296       _data_signpost_map_end:
F66:0297       
F66:0298       
F66:0299       ; signpost_palette.bin
F66:0300       
F66:0301       	cnop		0,_chunk_size
F66:0302       _data_signpost_palette:
F66:0303       	incbin	"../src/incbin/signpost_palette.bin"
               S03:00016B00:  0E 0E 00 00 04 44 0A 88 0E EE 0A 40 0C 80 02 82
               S03:00016B10:  02 A2 04 C4 00 28 00 6A 0E 0E 0E 0E 02 8E 04 0E
F66:0304       _data_signpost_palette_pos              equ _data_signpost_palette/_chunk_size
F66:0305       _data_signpost_palette_length           equ ((_data_signpost_palette_end-_data_signpost_palette)+(_chunk_size-1))/_chunk
F66:0306       _data_signpost_palette_end:
F66:0307       
F66:0308       
F66:0309       ; testmap_map.bin
F66:0310       
F66:0311       	cnop		0,_chunk_size
F66:0312       _data_testmap_map:
F66:0313       	incbin	"../src/incbin/testmap_map.bin"
               S03:00016B80:  40 40 00 08 00 0D 00 04 00 04 00 04 00 04 00 04
               S03:00016B90:  00 04 00 04 00 04 00 04 00 04 00 04 00 04 00 04
F66:0314       _data_testmap_map_pos                   equ _data_testmap_map/_chunk_size
F66:0315       _data_testmap_map_length                equ ((_data_testmap_map_end-_data_testmap_map)+(_chunk_size-1))/_chunk_size
F66:0316       _data_testmap_map_end:
F66:0317       
F66:0318       
F66:0319       ; testmap2_map.bin
F66:0320       
F66:0321       	cnop		0,_chunk_size
F66:0322       _data_testmap2_map:
F66:0323       	incbin	"../src/incbin/testmap2_map.bin"
               S03:00018C00:  40 40 00 04 00 04 00 04 00 04 00 04 00 04 00 04
               S03:00018C10:  00 04 00 04 00 04 00 04 00 04 00 04 00 04 00 04
F66:0324       _data_testmap2_map_pos                  equ _data_testmap2_map/_chunk_size
F66:0325       _data_testmap2_map_length               equ ((_data_testmap2_map_end-_data_testmap2_map)+(_chunk_size-1))/_chunk_size
F66:0326       _data_testmap2_map_end:
F66:0327       
F00:0021       	include		"../src/incbin/files.asm"
F67:0001       fileid_herotest_sprite_bank             equ 0
F67:0002       fileid_herotest_palette                 equ 1
F67:0003       fileid_herotest_sprite                  equ 2
F67:0004       fileid_herotest_big_sprite_bank         equ 3
F67:0005       fileid_herotest_big_palette             equ 4
F67:0006       fileid_herotest_big_sprite              equ 5
F67:0007       fileid_testsprite_sprite_bank           equ 6
F67:0008       fileid_testsprite_palette               equ 7
F67:0009       fileid_testsprite_sprite                equ 8
F67:0010       fileid_testsprite2_sprite_bank          equ 9
F67:0011       fileid_testsprite2_palette              equ 10
F67:0012       fileid_testsprite2_sprite               equ 11
F67:0013       fileid_testtiles_bank                   equ 12
F67:0014       fileid_testtiles_map                    equ 13
F67:0015       fileid_testtiles_palette                equ 14
F67:0016       fileid_untitled_splash_bank             equ 15
F67:0017       fileid_untitled_splash_map              equ 16
F67:0018       fileid_untitled_splash_palette          equ 17
F67:0019       fileid_herotestpng_sprite_bank          equ 18
F67:0020       fileid_herotestpng_palette              equ 19
F67:0021       fileid_herotestpng_sprite               equ 20
F67:0022       fileid_housetiles_bank                  equ 21
F67:0023       fileid_housetiles_map                   equ 22
F67:0024       fileid_housetiles_palette               equ 23
F67:0025       fileid_signpost_bank                    equ 24
F67:0026       fileid_signpost_map                     equ 25
F67:0027       fileid_signpost_palette                 equ 26
F67:0028       fileid_testmap_map                      equ 27
F67:0029       fileid_testmap2_map                     equ 28
F67:0030       
F67:0031       FileIDMap:
F67:0032       	dc.w	_data_herotest_sprite_bank_pos,_data_herotest_sprite_bank_length
               S03:0001AC02:  02 00
               S03:0001AC04:  00 02
F67:0033       	dc.w	_data_herotest_palette_pos,_data_herotest_palette_length
               S03:0001AC06:  02 02
               S03:0001AC08:  00 01
F67:0034       	dc.w	_data_herotest_sprite_pos,_data_herotest_sprite_length
               S03:0001AC0A:  02 03
               S03:0001AC0C:  00 01
F67:0035       	dc.w	_data_herotest_big_sprite_bank_pos,_data_herotest_big_sprite_bank_length
               S03:0001AC0E:  02 04
               S03:0001AC10:  00 05
F67:0036       	dc.w	_data_herotest_big_palette_pos,_data_herotest_big_palette_length
               S03:0001AC12:  02 09
               S03:0001AC14:  00 01
F67:0037       	dc.w	_data_herotest_big_sprite_pos,_data_herotest_big_sprite_length
               S03:0001AC16:  02 0A
               S03:0001AC18:  00 01
F67:0038       	dc.w	_data_testsprite_sprite_bank_pos,_data_testsprite_sprite_bank_length
               S03:0001AC1A:  02 0B
               S03:0001AC1C:  00 02
F67:0039       	dc.w	_data_testsprite_palette_pos,_data_testsprite_palette_length
               S03:0001AC1E:  02 0D
               S03:0001AC20:  00 01
F67:0040       	dc.w	_data_testsprite_sprite_pos,_data_testsprite_sprite_length
               S03:0001AC22:  02 0E
               S03:0001AC24:  00 01
F67:0041       	dc.w	_data_testsprite2_sprite_bank_pos,_data_testsprite2_sprite_bank_length
               S03:0001AC26:  02 0F
               S03:0001AC28:  00 03
F67:0042       	dc.w	_data_testsprite2_palette_pos,_data_testsprite2_palette_length
               S03:0001AC2A:  02 12
               S03:0001AC2C:  00 01
F67:0043       	dc.w	_data_testsprite2_sprite_pos,_data_testsprite2_sprite_length
               S03:0001AC2E:  02 13
               S03:0001AC30:  00 01
F67:0044       	dc.w	_data_testtiles_bank_pos,_data_testtiles_bank_length
               S03:0001AC32:  02 14
               S03:0001AC34:  00 14
F67:0045       	dc.w	_data_testtiles_map_pos,_data_testtiles_map_length
               S03:0001AC36:  02 28
               S03:0001AC38:  00 21
F67:0046       	dc.w	_data_testtiles_palette_pos,_data_testtiles_palette_length
               S03:0001AC3A:  02 49
               S03:0001AC3C:  00 01
F67:0047       	dc.w	_data_untitled_splash_bank_pos,_data_untitled_splash_bank_length
               S03:0001AC3E:  02 4A
               S03:0001AC40:  00 1C
F67:0048       	dc.w	_data_untitled_splash_map_pos,_data_untitled_splash_map_length
               S03:0001AC42:  02 66
               S03:0001AC44:  00 21
F67:0049       	dc.w	_data_untitled_splash_palette_pos,_data_untitled_splash_palette_length
               S03:0001AC46:  02 87
               S03:0001AC48:  00 01
F67:0050       	dc.w	_data_herotestpng_sprite_bank_pos,_data_herotestpng_sprite_bank_length
               S03:0001AC4A:  02 88
               S03:0001AC4C:  00 02
F67:0051       	dc.w	_data_herotestpng_palette_pos,_data_herotestpng_palette_length
               S03:0001AC4E:  02 8A
               S03:0001AC50:  00 01
F67:0052       	dc.w	_data_herotestpng_sprite_pos,_data_herotestpng_sprite_length
               S03:0001AC52:  02 8B
               S03:0001AC54:  00 01
F67:0053       	dc.w	_data_housetiles_bank_pos,_data_housetiles_bank_length
               S03:0001AC56:  02 8C
               S03:0001AC58:  00 05
F67:0054       	dc.w	_data_housetiles_map_pos,_data_housetiles_map_length
               S03:0001AC5A:  02 91
               S03:0001AC5C:  00 21
F67:0055       	dc.w	_data_housetiles_palette_pos,_data_housetiles_palette_length
               S03:0001AC5E:  02 B2
               S03:0001AC60:  00 01
F67:0056       	dc.w	_data_signpost_bank_pos,_data_signpost_bank_length
               S03:0001AC62:  02 B3
               S03:0001AC64:  00 02
F67:0057       	dc.w	_data_signpost_map_pos,_data_signpost_map_length
               S03:0001AC66:  02 B5
               S03:0001AC68:  00 21
F67:0058       	dc.w	_data_signpost_palette_pos,_data_signpost_palette_length
               S03:0001AC6A:  02 D6
               S03:0001AC6C:  00 01
F67:0059       	dc.w	_data_testmap_map_pos,_data_testmap_map_length
               S03:0001AC6E:  02 D7
               S03:0001AC70:  00 41
F67:0060       	dc.w	_data_testmap2_map_pos,_data_testmap2_map_length
               S03:0001AC72:  03 18
               S03:0001AC74:  00 41
F67:0061       
F00:0022       


Sections:
S01  CODE
S02  seg200
S03  seg10000


Sources:
F00  megadrive.asm
F01  ../src/platform/megadrive/macros.asm
F02  ../src/platform/megadrive/bootup.asm
F03  ../src/structs.asm
F04  ../src/macros.asm
F05  ../src/main.asm
F06  perf_stop
F07  perf_start
F08  ../src/core/mem.asm
F09  ../src/core/gameobjectmanager.asm
F10  pushm
F11  push
F12  pop
F13  popm
F14  pushm
F15  popm
F16  pushm
F17  popm
F18  ../src/platform/megadrive/mem.asm
F19  ../src/platform/megadrive/inp.asm
F20  ../src/platform/megadrive/rend.asm
F21  move_vram_addr
F22  move_vram_addr
F23  stack_alloc
F24  stack_write
F25  stack_write
F26  stack_write
F27  stack_write
F28  stack_read
F29  stack_read
F30  stack_read
F31  stack_write
F32  stack_read
F33  stack_read
F34  stack_free
F35  pushm
F36  popm
F37  push
F38  push
F39  pop
F40  pop
F41  push
F42  push
F43  pop
F44  pop
F45  push
F46  push
F47  push
F48  pop
F49  pop
F50  pop
F51  push
F52  pop
F53  push
F54  pop
F55  push
F56  pop
F57  push
F58  pop
F59  ../src/platform/megadrive/file.asm
F60  ../src/platform/megadrive/img.asm
F61  ../src/incasm/data.asm
F62  ../src/incasm/sintable.asm
F63  ../src/incasm/testtiles_image.asm
F64  ../src/incasm/untitled_splash_image.asm
F65  ../src/incasm/gameobject_hero.asm
F66  ../src/incbin/data.asm
F67  ../src/incbin/files.asm


Symbols:
fileid_signpost_palette EXPR(26) 
fileid_signpost_map EXPR(25) 
fileid_signpost_bank EXPR(24) 
fileid_housetiles_palette EXPR(23) 
fileid_housetiles_map EXPR(22) 
fileid_housetiles_bank EXPR(21) 
fileid_herotestpng_sprite EXPR(20) 
fileid_herotestpng_palette EXPR(19) 
fileid_herotestpng_sprite_bank EXPR(18) 
fileid_testsprite2_palette EXPR(10) 
fileid_testsprite_sprite EXPR(8) 
fileid_testsprite_palette EXPR(7) 
fileid_testsprite_sprite_bank EXPR(6) 
fileid_herotest_big_sprite EXPR(5) 
fileid_herotest_big_palette EXPR(4) 
fileid_herotest_big_sprite_bank EXPR(3) 
fileid_herotest_palette EXPR(1) 
_data_testmap2_map_length EXPR(complex expression) 
_data_testmap2_map_end LAB (0x1ac02) sec=seg10000 
_data_testmap2_map_pos LAB (0x318) align=1 sec=seg10000 
_data_testmap2_map LAB (0x18c00) sec=seg10000 
_data_testmap_map_length EXPR(complex expression) 
_data_testmap_map_end LAB (0x18b82) sec=seg10000 
_data_testmap_map_pos LAB (0x2d7) align=1 sec=seg10000 
_data_testmap_map LAB (0x16b80) sec=seg10000 
_data_signpost_palette_length EXPR(complex expression) 
_data_signpost_palette_end LAB (0x16b20) sec=seg10000 
_data_signpost_palette_pos LAB (0x2d6) align=1 sec=seg10000 
_data_signpost_palette LAB (0x16b00) sec=seg10000 
_data_signpost_map_length EXPR(complex expression) 
_data_signpost_map_end LAB (0x16a82) sec=seg10000 
_data_signpost_map_pos LAB (0x2b5) align=1 sec=seg10000 
_data_signpost_map LAB (0x15a80) sec=seg10000 
_data_signpost_bank_length EXPR(complex expression) 
_data_signpost_bank_end LAB (0x15a02) sec=seg10000 
_data_signpost_bank_pos LAB (0x2b3) align=1 sec=seg10000 
_data_signpost_bank LAB (0x15980) sec=seg10000 
_data_housetiles_palette_length EXPR(complex expression) 
_data_housetiles_palette_end LAB (0x15920) sec=seg10000 
_data_housetiles_palette_pos LAB (0x2b2) align=1 sec=seg10000 
_data_housetiles_palette LAB (0x15900) sec=seg10000 
_data_housetiles_map_length EXPR(complex expression) 
_data_housetiles_map_end LAB (0x15882) sec=seg10000 
_data_housetiles_map_pos LAB (0x291) align=1 sec=seg10000 
_data_housetiles_map LAB (0x14880) sec=seg10000 
_data_housetiles_bank_length EXPR(complex expression) 
_data_housetiles_bank_end LAB (0x14822) sec=seg10000 
_data_housetiles_bank_pos LAB (0x28c) align=1 sec=seg10000 
_data_housetiles_bank LAB (0x14600) sec=seg10000 
_data_herotestpng_sprite_length EXPR(complex expression) 
_data_herotestpng_sprite_end LAB (0x14587) sec=seg10000 
_data_herotestpng_sprite_pos LAB (0x28b) align=1 sec=seg10000 
_data_herotestpng_sprite LAB (0x14580) sec=seg10000 
_data_herotestpng_palette_length EXPR(complex expression) 
_data_herotestpng_palette_end LAB (0x14520) sec=seg10000 
_data_herotestpng_palette_pos LAB (0x28a) align=1 sec=seg10000 
_data_herotestpng_palette LAB (0x14500) sec=seg10000 
_data_herotestpng_sprite_bank_length EXPR(complex expression) 
_data_herotestpng_sprite_bank_end LAB (0x14482) sec=seg10000 
_data_herotestpng_sprite_bank_pos LAB (0x288) align=1 sec=seg10000 
_data_herotestpng_sprite_bank LAB (0x14400) sec=seg10000 
_data_untitled_splash_palette_length EXPR(complex expression) 
_data_untitled_splash_palette_end LAB (0x143a0) sec=seg10000 
_data_untitled_splash_palette_pos LAB (0x287) align=1 sec=seg10000 
_data_untitled_splash_palette LAB (0x14380) sec=seg10000 
_data_untitled_splash_map_length EXPR(complex expression) 
_data_untitled_splash_map_end LAB (0x14302) sec=seg10000 
_data_untitled_splash_map_pos LAB (0x266) align=1 sec=seg10000 
_data_untitled_splash_map LAB (0x13300) sec=seg10000 
_data_untitled_splash_bank_length EXPR(complex expression) 
_data_untitled_splash_bank_end LAB (0x132a2) sec=seg10000 
_data_untitled_splash_bank_pos LAB (0x24a) align=1 sec=seg10000 
_data_untitled_splash_bank LAB (0x12500) sec=seg10000 
_data_testtiles_palette_length EXPR(complex expression) 
_data_testtiles_palette_end LAB (0x124a0) sec=seg10000 
_data_testtiles_palette_pos LAB (0x249) align=1 sec=seg10000 
_data_testtiles_palette LAB (0x12480) sec=seg10000 
_data_testtiles_map_length EXPR(complex expression) 
_data_testtiles_map_end LAB (0x12402) sec=seg10000 
_data_testtiles_map_pos LAB (0x228) align=1 sec=seg10000 
_data_testtiles_map LAB (0x11400) sec=seg10000 
_data_testtiles_bank_length EXPR(complex expression) 
_data_testtiles_bank_end LAB (0x113a2) sec=seg10000 
_data_testtiles_bank_pos LAB (0x214) align=1 sec=seg10000 
_data_testtiles_bank LAB (0x10a00) sec=seg10000 
_data_testsprite2_sprite_length EXPR(complex expression) 
_data_testsprite2_sprite_end LAB (0x10988) sec=seg10000 
_data_testsprite2_sprite_pos LAB (0x213) align=1 sec=seg10000 
_data_testsprite2_sprite LAB (0x10980) sec=seg10000 
_data_testsprite2_palette_length EXPR(complex expression) 
_data_testsprite2_palette_end LAB (0x10920) sec=seg10000 
_data_testsprite2_palette_pos LAB (0x212) align=1 sec=seg10000 
_data_testsprite2_palette LAB (0x10900) sec=seg10000 
_data_testsprite2_sprite_bank_length EXPR(complex expression) 
_data_testsprite2_sprite_bank_end LAB (0x10882) sec=seg10000 
_data_testsprite2_sprite_bank_pos LAB (0x20f) align=1 sec=seg10000 
_data_testsprite2_sprite_bank LAB (0x10780) sec=seg10000 
_data_testsprite_sprite_length EXPR(complex expression) 
_data_testsprite_sprite_end LAB (0x10707) sec=seg10000 
_data_testsprite_sprite_pos LAB (0x20e) align=1 sec=seg10000 
_data_testsprite_sprite LAB (0x10700) sec=seg10000 
_data_testsprite_palette_length EXPR(complex expression) 
_data_testsprite_palette_end LAB (0x106a0) sec=seg10000 
_data_testsprite_palette_pos LAB (0x20d) align=1 sec=seg10000 
_data_testsprite_palette LAB (0x10680) sec=seg10000 
_data_testsprite_sprite_bank_length EXPR(complex expression) 
_data_testsprite_sprite_bank_end LAB (0x10602) sec=seg10000 
_data_testsprite_sprite_bank_pos LAB (0x20b) align=1 sec=seg10000 
_data_testsprite_sprite_bank LAB (0x10580) sec=seg10000 
_data_herotest_big_sprite_length EXPR(complex expression) 
_data_herotest_big_sprite_end LAB (0x10507) sec=seg10000 
_data_herotest_big_sprite_pos LAB (0x20a) align=1 sec=seg10000 
_data_herotest_big_sprite LAB (0x10500) sec=seg10000 
_data_herotest_big_palette_length EXPR(complex expression) 
_data_herotest_big_palette_end LAB (0x104a0) sec=seg10000 
_data_herotest_big_palette_pos LAB (0x209) align=1 sec=seg10000 
_data_herotest_big_palette LAB (0x10480) sec=seg10000 
_data_herotest_big_sprite_bank_length EXPR(complex expression) 
_data_herotest_big_sprite_bank_end LAB (0x10402) sec=seg10000 
_data_herotest_big_sprite_bank_pos LAB (0x204) align=1 sec=seg10000 
_data_herotest_big_sprite_bank LAB (0x10200) sec=seg10000 
_data_herotest_sprite_length EXPR(complex expression) 
_data_herotest_sprite_end LAB (0x10187) sec=seg10000 
_data_herotest_sprite_pos LAB (0x203) align=1 sec=seg10000 
_data_herotest_sprite LAB (0x10180) sec=seg10000 
_data_herotest_palette_length EXPR(complex expression) 
_data_herotest_palette_end LAB (0x10120) sec=seg10000 
_data_herotest_palette_pos LAB (0x202) align=1 sec=seg10000 
_data_herotest_palette LAB (0x10100) sec=seg10000 
_data_herotest_sprite_bank_length EXPR(complex expression) 
_data_herotest_sprite_bank_end LAB (0x10082) sec=seg10000 
_data_herotest_sprite_bank_pos LAB (0x200) align=1 sec=seg10000 
_data_herotest_sprite_bank LAB (0x10000) sec=seg10000 
fileid_testsprite2_sprite EXPR(11) 
fileid_testsprite2_sprite_bank EXPR(9) 
fileid_herotest_sprite EXPR(2) 
fileid_herotest_sprite_bank EXPR(0) 
fileid_untitled_splash_palette EXPR(17) 
fileid_untitled_splash_map EXPR(16) 
fileid_untitled_splash_bank EXPR(15) 
fileid_testtiles_map EXPR(13) 
FileIDMap LAB (0x1ac02) sec=seg10000 
 InitVDP .loop LAB (0xa90) sec=seg200 
VDPRegs LAB (0xa9a) sec=seg200 
 _rendCopyToVRAM .1 LAB (0x9c6) sec=seg200 
 rendLoadPalette .SlotAddresses LAB (0x9a2) sec=seg200 
 rendLoadPalette .done LAB (0x99e) sec=seg200 
 rendLoadTileMap .set_dimensions LAB (0x962) sec=seg200 
 rendLoadTileMap .height_128 LAB (0x95e) sec=seg200 
 rendLoadTileMap .height_64 LAB (0x958) sec=seg200 
 rendLoadTileMap .check_height LAB (0x94c) sec=seg200 
 rendLoadTileMap .width_128 LAB (0x948) sec=seg200 
 rendLoadTileMap .width_64 LAB (0x942) sec=seg200 
 rendLoadTileMap .SlotAddresses LAB (0x96e) sec=seg200 
 rendLoadTileMap .done LAB (0x96a) sec=seg200 
 rendSetSpriteDrawOrder .loop LAB (0x86e) sec=seg200 
_rendAddSprite_Index LAB (0xa0a) sec=seg200 
 rendLoadSprite .already_connected LAB (0x842) sec=seg200 
_rendCopySpriteToVRAM_Index LAB (0xa2c) sec=seg200 
_rendSetSpritePosition_Address LAB (0x9f6) sec=seg200 
_rendSetSpriteDimensions_Address LAB (0x9e2) sec=seg200 
_rendSetSpriteTileID_Address LAB (0x9ce) sec=seg200 
_rendIntegerToVRAMAddress LAB (0xa62) sec=seg200 
_rendCopyToVRAM LAB (0x9b2) sec=seg200 
fileLoad LAB (0xaca) sec=seg200 
 rendLoadTileBank .done LAB (0x7aa) sec=seg200 
 rendWaitVSync .loop LAB (0x746) sec=seg200 
InitVDP LAB (0xa82) sec=seg200 
 rendInit .clear_loop LAB (0x734) sec=seg200 
VRAM_TileMap1_Start EXPR(57344) 
VRAM_TileMap0_Start EXPR(49152) 
VRAM_HScroll_Start EXPR(48128) 
VRAM_SpriteAttributes_Start EXPR(47104) 
VRAM_SpriteTiles_Start EXPR(47104) 
VRAM_MapTiles_Start EXPR(0) 
VarHWSprites EXPR(16769054) 
VarLoadedTileMap EXPR(16769052) 
VarLoadedTileBank EXPR(16769050) 
VarLoadedPalette EXPR(16769048) 
VarLockedSpriteSlot EXPR(16769044) 
VarNextSpriteSlot EXPR(16769040) 
VarLockedSpriteAddress EXPR(16769036) 
VarNextSpriteAddress EXPR(16769032) 
_cpu_sprite_size EXPR(14) 
_cpu_sprite_tileid EXPR(12) 
_cpu_sprite_fileid_sprite EXPR(10) 
_cpu_sprite_fileid_tiles EXPR(8) 
_cpu_sprite_mirror EXPR(0) 
hw_sprite_byte_size EXPR(8) 
rend_num_sprites EXPR(80) 
INPUT_ACTION3 EXPR(5) 
INPUT_PAUSE EXPR(7) 
platform_renderer_size EXPR(1280) 
platform_renderer_start EXPR(16769024) 
platform_mem_start EXPR(16769024) 
platform_mem_size EXPR(8192) 
rendSetSpriteDrawOrder LAB (0x84c) sec=seg200 
 gomSortObjects .gom_to_sprite_loop LAB (0x672) sec=seg200 
 gomSortObjects .no_swap LAB (0x658) sec=seg200 
 gomSortObjects .compare_loop LAB (0x61a) sec=seg200 
 gomSortObjects .sort_again_loop LAB (0x610) sec=seg200 
rendSetSpritePosition LAB (0x89e) sec=seg200 
 gomRender .loop LAB (0x5d8) sec=seg200 
rendSetScrollXY LAB (0x752) sec=seg200 
rendLoadSprite LAB (0x7ac) sec=seg200 
 gomInit .loop LAB (0x50e) sec=seg200 
_gom_size EXPR(490) 
_gom_debug_b EXPR(489) 
_gom_draworder_sprites EXPR(449) 
_gom_debug_a EXPR(448) 
_gom_draworder EXPR(408) 
_gom_gameobjects EXPR(8) 
_gom_camera_y EXPR(6) 
_gom_camera_x EXPR(4) 
_gom_watermark EXPR(2) 
_gom_numobjects EXPR(0) 
_go_size EXPR(10) 
_go_sort EXPR(8) 
_go_anim_time EXPR(6) 
_go_sprite_handle EXPR(4) 
_go_world_pos_y EXPR(2) 
_go_world_pos_x EXPR(0) 
_gom_max_objects EXPR(40) 
memGetGameObjectManagerBaseAddress LAB (0x4fe) sec=seg200 
memGetPlatformBase LAB (0x696) sec=seg200 
gommem_end EXPR(512) 
gommem_size EXPR(256) 
gommem_base EXPR(256) 
usermem_end EXPR(256) 
usermem_size EXPR(256) 
usermem_base EXPR(0) 
totalmem_size EXPR(57344) 
fileid_testmap2_map EXPR(28) 
 _checkBorders .no_right LAB (0x4f6) sec=seg200 
 _checkBorders .done LAB (0x4f6) sec=seg200 
 _checkBorders .no_left LAB (0x4e2) sec=seg200 
 _cameraUpdate .down_ok LAB (0x4c4) sec=seg200 
 _cameraUpdate .no_adjust_down LAB (0x4c8) sec=seg200 
 _cameraUpdate .done LAB (0x4c8) sec=seg200 
 _cameraUpdate .up_ok LAB (0x4a4) sec=seg200 
 _cameraUpdate .no_adjust_up LAB (0x4aa) sec=seg200 
 _cameraUpdate .right_ok LAB (0x486) sec=seg200 
 _cameraUpdate .no_adjust_right LAB (0x48a) sec=seg200 
 _cameraUpdate .check_vertical_adjust LAB (0x48a) sec=seg200 
 _cameraUpdate .left_ok LAB (0x466) sec=seg200 
 _cameraUpdate .no_adjust_left LAB (0x46c) sec=seg200 
untitled_splash_image LAB (0xd1e) sec=seg200 
imgLoad LAB (0xae8) sec=seg200 
testtiles_image LAB (0xd18) sec=seg200 
 _inputUpdate .done LAB (0x44a) sec=seg200 
 _inputUpdate .scroll_down LAB (0x432) sec=seg200 
INPUT_DOWN EXPR(1) 
 _inputUpdate .scroll_up LAB (0x42c) sec=seg200 
INPUT_UP EXPR(0) 
 _inputUpdate .scroll_updown LAB (0x41e) sec=seg200 
 _inputUpdate .scroll_right LAB (0x41a) sec=seg200 
INPUT_RIGHT EXPR(3) 
 _inputUpdate .scroll_left LAB (0x414) sec=seg200 
INPUT_LEFT EXPR(2) 
 _inputUpdate .change_picture_1 LAB (0x442) sec=seg200 
INPUT_ACTION2 EXPR(4) 
 _inputUpdate .change_picture_0 LAB (0x438) sec=seg200 
INPUT_ACTION EXPR(6) 
inpUpdate LAB (0x6c2) sec=seg200 
rendSetSpriteFrame LAB (0x8c4) sec=seg200 
gomRender LAB (0x5a8) sec=seg200 
gomSortObjects LAB (0x5f8) sec=seg200 
rendWaitVSync LAB (0x740) sec=seg200 
CARG EXPR(0) INTERNAL 
gomSetCameraPosition LAB (0x59a) sec=seg200 
_cameraUpdate LAB (0x44c) sec=seg200 
gomSetPosition LAB (0x586) sec=seg200 
_checkBorders LAB (0x4ca) sec=seg200 
_inputUpdate LAB (0x3f6) sec=seg200 
 main .main_loop LAB (0x312) sec=seg200 
hero_go LAB (0xd24) sec=seg200 
gomLoadObject LAB (0x52a) sec=seg200 
potion_go LAB (0xd28) sec=seg200 
rendLoadTileMap LAB (0x8f6) sec=seg200 
fileid_testmap_map EXPR(27) 
rendLoadTileBank LAB (0x788) sec=seg200 
fileid_testtiles_bank EXPR(12) 
rendLoadPalette LAB (0x976) sec=seg200 
fileid_testtiles_palette EXPR(14) 
sintable LAB (0xb18) sec=seg200 
memGetUserBaseAddress LAB (0x4f8) sec=seg200 
gomInit LAB (0x508) sec=seg200 
_potionanim_time EXPR(22) 
_potion4_go_handle EXPR(20) 
_potion3_go_handle EXPR(18) 
_potion2_go_handle EXPR(16) 
_testanim_time EXPR(14) 
_potion_go_handle EXPR(12) 
_camera_pos_y EXPR(10) 
_camera_pos_x EXPR(8) 
_hero_sprite_pos_y EXPR(6) 
_hero_sprite_pos_x EXPR(4) 
_hero_go_handle EXPR(0) 
camera_padding_vertical EXPR(64) 
camera_padding_horizontal EXPR(96) 
room_height EXPR(512) 
room_width EXPR(512) 
screen_height EXPR(224) 
screen_width EXPR(320) 
main LAB (0x290) sec=seg200 
VarHsync EXPR(16769028) 
VarVsync EXPR(16769024) 
rendInit LAB (0x6e6) sec=seg200 
inpInit LAB (0x69e) sec=seg200 
  .clear_ram_loop LAB (0x224) sec=seg200 
  .no_copy_protection LAB (0x216) sec=seg200 
VBlankInterrupt LAB (0x288) sec=seg200 
HBlankInterrupt LAB (0x280) sec=seg200 
Interrupt LAB (0x27e) sec=seg200 
_chunk_size EXPR(128) 
__FO EXPR(0) INTERNAL 
__RS EXPR(0) INTERNAL 
REPTN EXPR(-1) INTERNAL 
__VASM EXPR(1) INTERNAL 
is_mega_drive EXPR(1) 

There have been no errors.
